import{l as ft,R as kt,a6 as Pt}from"./entry.fb0d1e13.js";import{c as p,a as Tt}from"./sha256.53cbc506.js";import{P as xt,I as Bt,Q as qt,b as $,R as W,T as dt,C as wt,V as Y,q as At,s as h,u as ht,e as St,a as _t,f as gt,p as ut}from"./pool.7066e590.js";import{D as e}from"./decimal.0bdeb344.js";function mt(i){const d={launchpad:p[i||"Sui"].launchpad,ido:p[i||"Sui"].ido,xcetus:p[i||"Sui"].xcetus,xcetus_dividends:p[i||"Sui"].xcetus_dividends,cetus_faucet:p[i||"Sui"].cetus_faucet,xtoken:p[i||"Sui"].xtoken,xtoken_dividends:p[i||"Sui"].xtoken_dividends,token_faucet:p[i||"Sui"].token_faucet,booster:p[i||"Sui"].booster,maker_bonus:p[i||"Sui"].maker_bonus,liquidity_stratefy:p[i||"Sui"].liquidity_stratefy,vaults:p[i||"Sui"].vaults,haedal:p[i||"Sui"].haedal,frams:p[i||"Sui"].frams},y={fullRpcUrl:localStorage.getItem(`${i}-currentRpclocal2`)||p[i||"Sui"].fullRpcUrl,simulationAccount:p[i||"Sui"].simulationAccount,cetus_config:p[i||"Sui"].cetus_config,clmm_pool:p[i||"Sui"].clmm_pool,integrate:p[i||"Sui"].integrate,deepbook:p[i||"Sui"].deepbook,deepbook_endpoint_v2:p[i||"Sui"].deepbook_endpoint_v2,aggregatorUrl:p[i||"Sui"].aggregatorUrl},m=new xt(y),n=new Bt(d,m),s=Tt(),V=ft(()=>s);kt(()=>{V.value.address&&(m.senderAddress=V.value.address)});const U=async()=>{const t=await n.Vaults.getVaultList();return t&&t.data||[]},R=async t=>{const c=await n.Vaults.getVault(t);return{...c,quota_based_type:qt(c.quota_based_type).full_address}},u=async t=>{if(m.senderAddress){const c=await n.ClmmSDK.fullClient.getBalance({owner:m.senderAddress,coinType:t});return c&&c.totalBalance}else return 0},o=t=>({transactionBlock:t,options:{showEffects:!0,showEvents:!0,showInput:!0,showRawInput:!0,showObjectChanges:!0,showBalanceChanges:!0}});return{getAutoPools:U,getLpBalance:u,getVault:async t=>await n.Vaults.getVault(t),deposit:async t=>{const{lowerTick:c,upperTick:A,slippage:g,rewarder_coin_types:v,isOnlyA:P,isOnlyB:b,currentTickIndex:f,decimal_b:N,request_id:q,staking_id:D,shouldRequestStake:T,farming_pool:I}=t;let a=t.fix_amount_a,r,_,k,S=f;if(P||b){let x;try{x=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:A,curSqrtPrice:t.curSqrtPrice,fix_amount_a:t.fix_amount_a,input_amount:t.coinAmount,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,clmm_pool:t.clmm_pool,use_route:!0,priceSplitPoint:g,request_id:q,staking_id:D,shouldRequestStake:T},!0)}catch{x=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:A,curSqrtPrice:t.curSqrtPrice,fix_amount_a:t.fix_amount_a,input_amount:t.coinAmount,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,clmm_pool:t.clmm_pool,use_route:!1,priceSplitPoint:g,request_id:q,staking_id:D,shouldRequestStake:T},!0)}x?(_=new $(x.afterSqrtPrice),r=x.fixAmountA===a?new $(W(t.coinAmount).sub(x.swapInAmount).toString()):new $(x.swapOutAmount),k={swap_amount:x.swapInAmount,a2b:a,input_amount:t.coinAmount,route_obj:x.routeObj,staking_id:x.staking_id},a=x.fixAmountA,S=dt.sqrtPriceX64ToTickIndex(new $(x.afterSqrtPrice))):(_=new $(t.curSqrtPrice),r=new $(t.coinAmount))}else _=t.curSqrtPrice,r=new $(t.coinAmount);let L,O,E;S>=c&&S<=A?(L=wt.estLiquidityAndcoinAmountFromOneAmounts(c,A,r,a,!0,g,_),O=a?r.toString():L.tokenMaxA.toString(),E=a?L.tokenMaxB.toString():r.toString()):S<c?(O=r.toNumber(),E=0):S>A&&(O=0,E=r.toNumber());const K=await n.Vaults.deposit({lowerTick:c,upperTick:A,vault_id:t.id,clmm_pool:t.clmm_pool,lp_token_type:t.lp_token_type,amount_a:O,amount_b:E,fix_amount_a:a,slippage:g,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,swapParams:k,farming_pool:I});return o(K)},remove:async t=>{const{lowerTick:c,upperTick:A,coinTypeA:g,coinTypeB:v,receiveAmount:P,clmm_pool:b,lowerSqrtPrice:f,upperSqrtPrice:N,fix_amount_a:q,curSqrtPrice:D,slippage:T,rewarder_coin_types:I,id:a,liquidity:r,swapParams:_,isOnlyA:k,isOnlyB:S,sliderVal:L,positionInfo:O,maxLiquidity:E,request_id:K,farming_pool:x}=t,F=await R(a),M=await m.Pool.getPool(F.pool_id);let B,j,z,Z,J;const C=Y.get_share_liquidity_by_amount(F,L==100?O.balance:t.lpTokenAmount);if(k||S){try{B=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:A,curSqrtPrice:M.current_sqrt_price,fix_amount_a:q,receive_amount:P,coinTypeA:g,coinTypeB:v,clmm_pool:b,use_route:!0,priceSplitPoint:T,removeLiquidity:L==100?C:"",maxLiquidity:E,request_id:K})}catch{B=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:A,curSqrtPrice:M.current_sqrt_price,fix_amount_a:q,receive_amount:P,coinTypeA:g,coinTypeB:v,clmm_pool:b,use_route:!1,priceSplitPoint:T,removeLiquidity:L==100?C:"",maxLiquidity:E,request_id:K})}if(B){const G=Y.get_share_liquidity_by_amount(F,O.balance);j=wt.getCoinAmountFromLiquidity(new $(L==100?G:B.liquidity),new $(M.current_sqrt_price),f,N,!1),Y.get_protocol_fee_amount(F,j.coinA.toString()),Y.get_protocol_fee_amount(F,j.coinB.toString()),z=L==100?O.balance:Y.get_lp_amount_by_liquidity(F,B.liquidity),Z=W(j.coinA.toString()).mul(W(1-t.slippage)),J=W(j.coinB.toString()).mul(W(1-t.slippage))}}else j=wt.getCoinAmountFromLiquidity(new $(C),new $(M.current_sqrt_price),f,N,!1),z=t.lpTokenAmount,Z=W(j.coinA.toString()).mul(W(1-t.slippage)),J=W(j.coinB.toString()).mul(W(1-t.slippage));const tt={vault_id:t.id,clmm_pool:t.clmm_pool,lp_token_type:t.lp_token_type,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,lp_token_amount:z,min_amount_a:At(Z,0)||"",min_amount_b:At(J,0)||"",rewarder_coin_types:[],slippage:t.slippage,farming_pool:x};(k||S)&&(tt.swapParams={a2b:!q,swap_amount:B==null?void 0:B.swapInAmount,route_obj:B.routeObj});const Q=await n.Vaults.remove(tt);return o(Q)},getAutoPool:R,calculateDepositSwapAmount:async t=>{const{lowerTick:c,upperTick:A,curSqrtPrice:g,fix_amount_a:v,input_amount:P,coinTypeA:b,coinTypeB:f,clmm_pool:N,slippage:q,decimals:D,request_id:T,staking_id:I,shouldRequestStake:a}=t;let r;try{r=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:A,curSqrtPrice:g,fix_amount_a:v,input_amount:P,coinTypeA:b,coinTypeB:f,clmm_pool:N,use_route:!0,priceSplitPoint:q,request_id:T,staking_id:I,shouldRequestStake:a},!0)}catch(_){if(String(_)=="Error: route unavailable"&&(r=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:A,curSqrtPrice:g,fix_amount_a:v,input_amount:P,coinTypeA:b,coinTypeB:f,clmm_pool:N,use_route:!1,priceSplitPoint:q,request_id:T,staking_id:I,shouldRequestStake:a},!0)),String(_)=="Error: HaedalStakeSuiAmountError")return"HaedalStakeSuiAmountError"}if(r){const _=new e(r.swapOutAmount);return{...r,swapOutAmountLimit:h(_.sub(_.mul(q)).toNumber(),D)}}return r},calculateRemoveSwapAmount:async t=>{const{lowerTick:c,upperTick:A,curSqrtPrice:g,fix_amount_a:v,receiveAmount:P,coinTypeA:b,coinTypeB:f,clmm_pool:N,slippage:q,decimals:D,liquidity:T,maxLiquidity:I,request_id:a}=t;let r;try{r=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:A,curSqrtPrice:g,fix_amount_a:v,receive_amount:P,coinTypeA:b,coinTypeB:f,clmm_pool:N,use_route:!0,priceSplitPoint:q,removeLiquidity:T,maxLiquidity:I,request_id:a})}catch(_){String(_)=="Error: route unavailable"&&(r=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:A,curSqrtPrice:g,fix_amount_a:v,receive_amount:P,coinTypeA:b,coinTypeB:f,clmm_pool:N,use_route:!1,priceSplitPoint:q,removeLiquidity:T,maxLiquidity:I,request_id:a}))}if(r){const _=new e(r.swapOutAmount);return{...r,swapOutAmountLimit:h(_.sub(_.mul(q)).toNumber(),D)}}return r}}}const Ut=Pt("autoPool",{state:()=>({autoPoolList:[],autoPoolObj:{},positionInfoObj:{},positionInfoList:[],positionUSDObj:{},apyObj:{},currentAutoPoolStatus:"STATUS_RUNNING",slippage:localStorage.getItem("cetus-auto-slippage")||"0.1",autoPoolLoading:!1}),getters:{getPoolStore(){return ht()}},actions:{async getAutoPoolList(){const d=await mt("Sui").getAutoPools(),y=this.getPoolStore,m=p.Sui.vaultFilter,{data:n}=await fetch(`${p.Sui.api}/v2/sui/auto_pools`).then(u=>u.json()),s=(n==null?void 0:n.pools)||[],V=d.filter(u=>s.some(o=>o.object_id===u.id)),U=p.Sui.haedal.config.support_stakings,R=(m?V:d).map(u=>{const o=y.poolConfigObj[u.pool_id],w=[o!=null&&o.needReverse?o.coin_b_address:o.coin_a_address,o!=null&&o.needReverse?o.coin_a_address:o.coin_b_address];return o.rewarderInfo.forEach(l=>{l.emissionsEveryDay>0&&w.push(l.coinAddress)}),o.stable_farming.stable_rewarder.forEach(l=>{l.amount_second>0&&w.push(l.coin)}),{...o,id:u.id,lp_token_type:u.lp_token_type,autoPoolPositionInfo:u.position,is_pause:u.is_pause,total_supply:u.total_supply,liquidity:u.liquidity,protocol_fee_rate:u.protocol_fee_rate,max_quota:u.max_quota,staking_id:u.staking_id,quota_based_type:qt(u.quota_based_type).full_address,supportHaedalStake:U.filter(l=>l.staking_id==u.staking_id).length>0,isTokenA:o.needReverse?o.coin_b_address=="0000000000000000000000000000000000000000000000000000000000000002::sui::SUI":o.coin_a_address=="0000000000000000000000000000000000000000000000000000000000000002::sui::SUI",rewardList:Array.from(new Set(w))}});this.autoPoolList=R,this.autoPoolObj=Object.fromEntries(R.map((u,o)=>[u.address,u])),this.getMyAutoPoolPosition()},async getMyAutoPoolPosition(){var s,V,U,R;const i=mt("Sui"),d=this.autoPoolList,y=St("Sui"),m=[],{RATES:n}=this.getPoolStore;for(let u=0;u<d.length;u++){const o=d[u],w=await y.getPool(o.address),l=await i.getLpBalance(d[u].lp_token_type),X=(await y.getTokenListByCoinType([d[u].lp_token_type]))[0],ot=((s=n[o.coinA.address])==null?void 0:s.price)||"",H=((V=n[o.coinB.address])==null?void 0:V.price)||"",t=o.autoPoolPositionInfo.tick_lower_index,c=o.autoPoolPositionInfo.tick_upper_index,A=Number(l)>0?Y.get_share_liquidity_by_amount({liquidity:o==null?void 0:o.liquidity,total_supply:o==null?void 0:o.total_supply},l):0,g={tick_lower_index:t,tick_upper_index:c,current_sqrt_price:w==null?void 0:w.current_sqrt_price,liquidity:A},v=await y.getCoinAmountFromLiquidity({pool:{...o,current_sqrt_price:w==null?void 0:w.current_sqrt_price},position:g,roundUp:!1}),P=v.coinaAmount,b=v.coinbAmount,f=P,N=b,q=o.coinA.decimals,D=o.coinB.decimals,T=y.TickMath.tickIndexToPrice(Number(t),q,D).toString(),I=y.TickMath.tickIndexToPrice(Number(c),q,D).toString(),a=new e(ot).mul(new e(P)).toNumber(),r=new e(H).mul(new e(b)).toNumber(),_=a>0&&a<.01?"<$0.01":`$${_t(h(a,2))}`,k=r>0&&r<.01?"<$0.01":`$${_t(h(r,2))}`;dt.sqrtPriceX64ToPrice(w.current_sqrt_price,q,D);const S=await y.getCoinAmountFromLiquidity({pool:{...o,tick_lower_index:t,tick_upper_index:c,current_sqrt_price:w==null?void 0:w.current_sqrt_price},position:{...g,liquidity:o.liquidity},roundUp:!1}),L=new e(S.coinaAmount).toNumber(),O=new e(S.coinbAmount).toNumber(),E=h(new e(L).mul(new e(ot)).toNumber(),2),K=h(new e(O).mul(new e(H)).toNumber(),2),{ratioA:x,ratioB:F}=Y.calculateDepositRatio(t,c,new $.BN(w==null?void 0:w.current_sqrt_price)),M=x.mul(100).toNumber().toFixed(0),B=100-Number(M);let j=0;Number(l)>0&&(j=new e(l).div(Math.pow(10,X.decimals)));const z=new e(a).add(new e(r)).toNumber(),Z=ot&&H?z>0&&z<.01?"<0.01":h(new e(a).add(new e(r)).toString(),2):"--",J=o.total_supply;let C=0;j>0&&J>0&&(C=new e(j).mul(Math.pow(10,X.decimals)).div(new e(J)).mul(100).toNumber());const tt=new e(1).div(Math.pow(10,o.decimals)).toNumber();let Q=0;if(C>1)Q=h(C,2);else if(C>0&&C<tt)Q=`<${tt}`;else if(C==0)Q=0;else{const nt=gt(C),pt=nt==-1?2:nt+2;Q=h(C,pt)}const G=(await y.getTokenListByCoinType([o.quota_based_type]))[0],yt=ut(o.max_quota,G.decimals),st=G.address==o.coin_b_address,rt=st?new e(S.coinaAmount).mul(o.price).add(S.coinbAmount):new e(S.coinaAmount).mul(1/o.price).add(S.coinbAmount),ct=((U=n[G.address])==null?void 0:U.price)||"",et=rt.mul(new e(ct)).toNumber(),it=yt,at=st?new e(S.coinaAmount).mul(o.price).add(S.coinbAmount):new e(S.coinaAmount).mul(1/o.price).add(S.coinbAmount),lt=new e(it).sub(at).mul(H).toNumber();this.positionInfoObj[o.id]={tick_lower_index:t,tick_upper_index:c,current_sqrt_price:w.current_sqrt_price,myLiquidity:ut(l,X.decimals),amountA:f,amountB:N,...o,lpInfo:X,myAmountAUSD:_,myAmountBUSD:k,myLiquidityUSD:Z,myShare:Q,minPrice:T,maxPrice:I,poolCoinARatio:M,poolCoinBRatio:B,poolCoinANum:L,poolCoinBNum:O,poolCoinAUSD:E,poolCoinBUSD:K,quoteUSD:it,poolUSD:et,balance:l,quoteCoinInfo:G,remainingTokenUSD:lt,currentDeposit:et,positionLiquidity:A},m.push({tick_lower_index:t,tick_upper_index:c,current_sqrt_price:(R=o==null?void 0:o.object)==null?void 0:R.current_sqrt_price,myLiquidity:ut(l,X.decimals),amountA:f,amountB:N,...o,lpInfo:X,myAmountAUSD:_,myAmountBUSD:k,myLiquidityUSD:Z,myShare:Q,minPrice:T,maxPrice:I,poolCoinARatio:M,poolCoinBRatio:B,poolCoinANum:L,poolCoinBNum:O,poolCoinAUSD:E,poolCoinBUSD:K,quoteUSD:it,poolUSD:et,balance:l})}this.positionInfoList=m},async updatePositionItem(i){var rt,ct,et,it,at,lt,nt;const d=mt("Sui"),y=St("Sui"),m=await d.getAutoPool(i),n=await y.getPool(m.pool_id),s={...this.positionInfoObj[i],autoPoolPositionInfo:m.position,...n},V=await d.getLpBalance(s.lp_token_type),U=(await y.getTokenListByCoinType([s.lp_token_type]))[0],R=s.autoPoolPositionInfo.tick_lower_index,u=s.autoPoolPositionInfo.tick_upper_index;let o;m.total_supply==0?o=0:o=Y.get_share_liquidity_by_amount(m,String(V));const w={tick_lower_index:R,tick_upper_index:u,current_sqrt_price:n.current_sqrt_price,liquidity:o},l=y.getCoinAmountFromLiquidity({pool:{current_sqrt_price:n.current_sqrt_price,...s},position:w,roundUp:!1}),X=l.coinaAmount,ot=l.coinbAmount,{RATES:H}=this.getPoolStore,t=m.total_supply,c=dt.sqrtPriceX64ToPrice(n.current_sqrt_price,(rt=s==null?void 0:s.coinA)==null?void 0:rt.decimals,(ct=s==null?void 0:s.coinB)==null?void 0:ct.decimals),A=2,g=2,v=((it=H[(et=s==null?void 0:s.coinA)==null?void 0:et.address])==null?void 0:it.price)||0,P=((lt=H[(at=s==null?void 0:s.coinB)==null?void 0:at.address])==null?void 0:lt.price)||0,b=new e(v).mul(new e(l==null?void 0:l.coinaAmount)).toNumber(),f=new e(P).mul(new e(l==null?void 0:l.coinbAmount)).toNumber(),N=b>0&&b<.01?"<$0.01":`$${_t(h(b,2))}`,q=f>0&&f<.01?"<$0.01":`$${_t(h(f,2))}`;let D=new e(0);Number(V)>0&&(D=new e(V).div(Math.pow(10,U==null?void 0:U.decimals)));const T=new e(b).add(new e(f)).toNumber(),I=v&&P?T>0&&T<.01?"<0.01":h(new e(b).add(new e(f)).toString(),2):"--";let a=0;D.toNumber()>0&&t>0&&(a=new e(D).mul(Math.pow(10,U.decimals)).div(new e(t)).mul(100).toNumber());const r=new e(1).div(Math.pow(10,s.decimals)).toNumber();let _=0;if(a>1)_=h(a,2);else if(a>0&&a<r)_=`<${r}`;else if(a==0)_=0;else{const pt=gt(a),bt=pt==-1?2:pt+2;_=h(a,bt)}dt.sqrtPriceX64ToPrice(n.current_sqrt_price,A,g);const k=await y.getCoinAmountFromLiquidity({pool:{...s,tick_lower_index:R,tick_upper_index:u,current_sqrt_price:n==null?void 0:n.current_sqrt_price},position:{...w,liquidity:m.liquidity},roundUp:!1}),S=new e(k.coinaAmount).toNumber(),L=new e(k.coinbAmount).toNumber(),O=h(new e(S).mul(new e(v)).toNumber(),2),E=h(new e(L).mul(new e(P)).toNumber(),2),{ratioA:K,ratioB:x}=Y.calculateDepositRatio(R,u,new $.BN(n==null?void 0:n.current_sqrt_price)),F=K.mul(100).toNumber().toFixed(0),M=100-Number(F),B=(await y.getTokenListByCoinType([m.quota_based_type]))[0],j=ut(m.max_quota,B.decimals),z=B.address==s.coin_b_address,Z=z?new e(k.coinaAmount).mul(s.price).add(k.coinbAmount):new e(k.coinaAmount).mul(1/s.price).add(k.coinbAmount),J=((nt=H[B.address])==null?void 0:nt.price)||"",C=Z.mul(new e(J)).toNumber(),tt=j,Q=z?new e(k.coinaAmount).mul(s.price).add(k.coinbAmount):new e(k.coinaAmount).mul(1/s.price).add(k.coinbAmount),G=new e(tt).sub(Q).mul(P).toNumber(),yt=y.TickMath.tickIndexToPrice(Number(R),A,g).toString(),st=y.TickMath.tickIndexToPrice(Number(u),A,g).toString();this.positionInfoObj[i]={...s,tick_lower_index:R,tick_upper_index:u,current_sqrt_price:n.current_sqrt_price,myLiquidity:ut(V,U==null?void 0:U.decimals),amountA:X,amountB:ot,myShare:_,myAmountAUSD:N,myAmountBUSD:q,myLiquidityUSD:I,poolCoinARatio:F,poolCoinBRatio:M,poolCoinANum:S,poolCoinBNum:L,poolCoinAUSD:O,poolCoinBUSD:E,quoteUSD:tt,balance:V,price:c,quoteCoinInfo:B,remainingTokenUSD:G,currentDeposit:C,poolUSD:C,positionLiquidity:o,liquidity:m==null?void 0:m.liquidity,minPrice:yt,maxPrice:st},this.autoPoolLoading=!1},async getAutoPoolAPY(){try{const{data:i}=await fetch(`${p.Sui.api}/v2/sui/auto_pools`).then(d=>d.json());i&&i.pools&&i.pools.length>0&&(this.apyObj=Object.fromEntries(i.pools.map((d,y)=>[d.object_id,{...d,apr:d.apr.replace("%","")>0&&d.apr.replace("%","")<.01?"<0.01%":h(d.apr.replace("%",""),2)+"%",resultApr:d.apr.replace("%","")}])))}catch{this.apyObj={}}},async getVault(i,d){const y=mt("Sui");d||(this.autoPoolLoading=!0);const{status:m}=await y.getVault(i);this.currentAutoPoolStatus=m,this.updatePositionItem(i)},setSlippage(i){this.slippage=i,localStorage.setItem("cetus-auto-slippage",i)}}});export{mt as a,Ut as u};
