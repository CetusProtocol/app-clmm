import{a6 as gt,l as ft,Q as kt,a7 as Pt}from"./entry.c1586b15.js";import{c as _,a as Tt}from"./sha256.a617abee.js";import{M as xt,N as wt,b as R,O as z,T as pt,C as rt,o as dt,s as L,u as Bt,e as yt,a as at,f as At,p as nt}from"./pool.e1279739.js";import{C as vt,V as G}from"./index.a4b51a25.js";import{D as o}from"./decimal.0bdeb344.js";function lt(e){const m={launchpad:_[e||"Sui"].launchpad,ido:_[e||"Sui"].ido,xcetus:_[e||"Sui"].xcetus,xcetus_dividends:_[e||"Sui"].xcetus_dividends,cetus_faucet:_[e||"Sui"].cetus_faucet,xtoken:_[e||"Sui"].xtoken,xtoken_dividends:_[e||"Sui"].xtoken_dividends,token_faucet:_[e||"Sui"].token_faucet,booster:_[e||"Sui"].booster,maker_bonus:_[e||"Sui"].maker_bonus,liquidity_stratefy:_[e||"Sui"].liquidity_stratefy,vaults:_[e||"Sui"].vaults},A={fullRpcUrl:localStorage.getItem(`${e}-currentRpclocal2`)||_[e||"Sui"].fullRpcUrl,simulationAccount:_[e||"Sui"].simulationAccount,cetus_config:_[e||"Sui"].cetus_config,clmm_pool:_[e||"Sui"].clmm_pool,integrate:_[e||"Sui"].integrate,deepbook:_[e||"Sui"].deepbook,deepbook_endpoint_v2:_[e||"Sui"].deepbook_endpoint_v2,aggregatorUrl:_[e||"Sui"].aggregatorUrl},r=new xt(A),n=gt(new vt(m,r)),a=Tt(),O=ft(()=>a);kt(()=>{O.value.address&&(r.senderAddress=O.value.address)});const F=async()=>{const t=await n.Vaults.getVaultList();return t&&t.data||[]},s=async t=>{const u=await n.Vaults.getVault(t);return{...u,quota_based_type:wt(u.quota_based_type).full_address}},h=async t=>{if(r.senderAddress){const u=await n.ClmmSDK.fullClient.getBalance({owner:r.senderAddress,coinType:t});return u&&u.totalBalance}else return 0},i=t=>({transactionBlock:t,options:{showEffects:!0,showEvents:!0,showInput:!0,showRawInput:!0,showObjectChanges:!0,showBalanceChanges:!0}});return{getAutoPools:F,getLpBalance:h,getVault:async t=>await n.Vaults.getVault(t),deposit:async t=>{const{lowerTick:u,upperTick:w,slippage:T,rewarder_coin_types:C,isOnlyA:x,isOnlyB:b,currentTickIndex:S,decimal_b:D}=t;let l=t.fix_amount_a,d,g,B,c=S;if(x||b){let p;try{p=await n.Vaults.calculateDepositSwapAmount({lowerTick:u,upperTick:w,curSqrtPrice:t.curSqrtPrice,fix_amount_a:t.fix_amount_a,input_amount:t.coinAmount,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,clmm_pool:t.clmm_pool,use_route:!0,priceSplitPoint:T},!0)}catch{p=await n.Vaults.calculateDepositSwapAmount({lowerTick:u,upperTick:w,curSqrtPrice:t.curSqrtPrice,fix_amount_a:t.fix_amount_a,input_amount:t.coinAmount,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,clmm_pool:t.clmm_pool,use_route:!1,priceSplitPoint:T},!0)}p?(g=new R(p.afterSqrtPrice),d=p.fixAmountA===l?new R(z(t.coinAmount).sub(p.swapInAmount).toString()):new R(p.swapOutAmount),B={swap_amount:p.swapInAmount,a2b:l,input_amount:t.coinAmount,route_obj:p.routeObj},l=p.fixAmountA,c=pt.sqrtPriceX64ToTickIndex(new R(p.afterSqrtPrice))):(g=new R(t.curSqrtPrice),d=new R(t.coinAmount))}else g=t.curSqrtPrice,d=new R(t.coinAmount);let q,f,y;c>=u&&c<=w?(q=rt.estLiquidityAndcoinAmountFromOneAmounts(u,w,d,l,!0,T,g),f=l?d.toString():q.tokenMaxA.toString(),y=l?q.tokenMaxB.toString():d.toString()):c<u?(f=d.toNumber(),y=0):c>w&&(f=0,y=d.toNumber());const v=await n.Vaults.deposit({lowerTick:u,upperTick:w,vault_id:t.id,clmm_pool:t.clmm_pool,lp_token_type:t.lp_token_type,amount_a:f,amount_b:y,fix_amount_a:l,slippage:T,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,swapParams:B});return i(v)},remove:async t=>{const{lowerTick:u,upperTick:w,coinTypeA:T,coinTypeB:C,receiveAmount:x,clmm_pool:b,lowerSqrtPrice:S,upperSqrtPrice:D,fix_amount_a:l,curSqrtPrice:d,slippage:g,rewarder_coin_types:B,id:c,liquidity:q,swapParams:f,isOnlyA:y,isOnlyB:v,sliderVal:p,positionInfo:$,maxLiquidity:Z}=t,j=await s(c),tt=await r.Pool.getPool(j.pool_id);let N,U,V,Q,X;const K=G.get_share_liquidity_by_amount(j,p==100?$.balance:t.lpTokenAmount);if(y||v){try{N=await n.Vaults.calculateRemoveSwapAmount({lowerTick:u,upperTick:w,curSqrtPrice:tt.current_sqrt_price,fix_amount_a:l,receive_amount:x,coinTypeA:T,coinTypeB:C,clmm_pool:b,use_route:!0,priceSplitPoint:g,removeLiquidity:p==100?K:"",maxLiquidity:Z})}catch{N=await n.Vaults.calculateRemoveSwapAmount({lowerTick:u,upperTick:w,curSqrtPrice:tt.current_sqrt_price,fix_amount_a:l,receive_amount:x,coinTypeA:T,coinTypeB:C,clmm_pool:b,use_route:!1,priceSplitPoint:g,removeLiquidity:p==100?K:"",maxLiquidity:Z})}if(N){const W=G.get_share_liquidity_by_amount(j,$.balance);U=rt.getCoinAmountFromLiquidity(new R(p==100?W:N.liquidity),new R(tt.current_sqrt_price),S,D,!1),G.get_protocol_fee_amount(j,U.coinA.toString()),G.get_protocol_fee_amount(j,U.coinB.toString()),V=p==100?$.balance:G.get_lp_amount_by_liquidity(j,N.liquidity),Q=z(U.coinA.toString()).mul(z(1-t.slippage)),X=z(U.coinB.toString()).mul(z(1-t.slippage))}}else U=rt.getCoinAmountFromLiquidity(new R(K),d,S,D,!1),U=rt.getCoinAmountFromLiquidity(new R(K),d,S,D,!1),V=t.lpTokenAmount,Q=z(U.coinA.toString()).mul(z(1-t.slippage)),X=z(U.coinB.toString()).mul(z(1-t.slippage));const H={vault_id:t.id,clmm_pool:t.clmm_pool,lp_token_type:t.lp_token_type,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,lp_token_amount:V,min_amount_a:dt(Q,0)||"",min_amount_b:dt(X,0)||"",rewarder_coin_types:[],slippage:t.slippage};(y||v)&&(H.swapParams={a2b:!l,swap_amount:N==null?void 0:N.swapInAmount,route_obj:N.routeObj});const I=await n.Vaults.remove(H);return i(I)},getAutoPool:s,calculateDepositSwapAmount:async t=>{const{lowerTick:u,upperTick:w,curSqrtPrice:T,fix_amount_a:C,input_amount:x,coinTypeA:b,coinTypeB:S,clmm_pool:D,slippage:l,decimals:d,request_id:g}=t;let B;try{B=await n.Vaults.calculateDepositSwapAmount({lowerTick:u,upperTick:w,curSqrtPrice:T,fix_amount_a:C,input_amount:x,coinTypeA:b,coinTypeB:S,clmm_pool:D,use_route:!0,priceSplitPoint:l,request_id:g},!0)}catch(c){String(c)=="Error: route unavailable"&&(B=await n.Vaults.calculateDepositSwapAmount({lowerTick:u,upperTick:w,curSqrtPrice:T,fix_amount_a:C,input_amount:x,coinTypeA:b,coinTypeB:S,clmm_pool:D,use_route:!1,priceSplitPoint:l,request_id:g},!0))}if(B){const c=new o(B.swapOutAmount);return{...B,swapOutAmountLimit:L(c.sub(c.mul(l)).toNumber(),d)}}return B},calculateRemoveSwapAmount:async t=>{const{lowerTick:u,upperTick:w,curSqrtPrice:T,fix_amount_a:C,receiveAmount:x,coinTypeA:b,coinTypeB:S,clmm_pool:D,slippage:l,decimals:d,liquidity:g,maxLiquidity:B,request_id:c}=t;let q;try{q=await n.Vaults.calculateRemoveSwapAmount({lowerTick:u,upperTick:w,curSqrtPrice:T,fix_amount_a:C,receive_amount:x,coinTypeA:b,coinTypeB:S,clmm_pool:D,use_route:!0,priceSplitPoint:l,removeLiquidity:g,maxLiquidity:B,request_id:c})}catch(f){String(f)=="Error: route unavailable"&&(q=await n.Vaults.calculateRemoveSwapAmount({lowerTick:u,upperTick:w,curSqrtPrice:T,fix_amount_a:C,receive_amount:x,coinTypeA:b,coinTypeB:S,clmm_pool:D,use_route:!1,priceSplitPoint:l,removeLiquidity:g,maxLiquidity:B,request_id:c}))}if(q){const f=new o(q.swapOutAmount);return{...q,swapOutAmountLimit:L(f.sub(f.mul(l)).toNumber(),d)}}return q}}}const Ot=Pt("autoPool",{state:()=>({autoPoolList:[],autoPoolObj:{},positionInfoObj:{},positionInfoList:[],positionUSDObj:{},apyObj:{},currentAutoPoolStatus:"STATUS_RUNNING",slippage:localStorage.getItem("cetus-auto-slippage")||"0.1"}),getters:{getPoolStore(){return Bt()}},actions:{async getAutoPoolList(){const m=await lt("Sui").getAutoPools(),A=this.getPoolStore,r=_.Sui.vaultFilter,{data:n}=await fetch(`${_.Sui.api}/v2/sui/auto_pools`).then(s=>s.json()),a=(n==null?void 0:n.pools)||[],O=m.filter(s=>a.some(h=>h.object_id===s.id)),F=(r?O:m).map(s=>({...A.poolConfigObj[s.pool_id],id:s.id,lp_token_type:s.lp_token_type,autoPoolPositionInfo:s.positins[0],is_pause:s.is_pause,total_supply:s.total_supply,liquidity:s.liquidity,protocol_fee_rate:s.protocol_fee_rate,max_quota:s.max_quota,quota_based_type:wt(s.quota_based_type).full_address}));this.autoPoolList=F,this.autoPoolObj=Object.fromEntries(F.map((s,h)=>[s.address,s])),this.getMyAutoPoolPosition()},async getMyAutoPoolPosition(){var a,O,F,s;const e=lt("Sui"),m=this.autoPoolList,A=yt("Sui"),r=[],{RATES:n}=this.getPoolStore;for(let h=0;h<m.length;h++){const i=m[h],k=await A.getPool(i.address),P=await e.getLpBalance(m[h].lp_token_type),M=(await A.getTokenListByCoinType([m[h].lp_token_type]))[0],J=((a=n[i.coinA.address])==null?void 0:a.price)||"",E=((O=n[i.coinB.address])==null?void 0:O.price)||"",t=i.autoPoolPositionInfo.tick_lower_index,u=i.autoPoolPositionInfo.tick_upper_index,w=Number(P)>0?G.get_share_liquidity_by_amount({liquidity:i==null?void 0:i.liquidity,total_supply:i==null?void 0:i.total_supply},P):0,T={tick_lower_index:t,tick_upper_index:u,current_sqrt_price:k==null?void 0:k.current_sqrt_price,liquidity:w},C=await A.getCoinAmountFromLiquidity({pool:{...i,current_sqrt_price:k==null?void 0:k.current_sqrt_price},position:T,roundUp:!1}),x=C.coinaAmount,b=C.coinbAmount,S=x,D=b,l=i.coinA.decimals,d=i.coinB.decimals,g=A.TickMath.tickIndexToPrice(Number(t),l,d).toString(),B=A.TickMath.tickIndexToPrice(Number(u),l,d).toString(),c=new o(J).mul(new o(x)).toNumber(),q=new o(E).mul(new o(b)).toNumber(),f=c>0&&c<.01?"<$0.01":`$${at(L(c,2))}`,y=q>0&&q<.01?"<$0.01":`$${at(L(q,2))}`;pt.sqrtPriceX64ToPrice(k.current_sqrt_price,l,d);const v=await A.getCoinAmountFromLiquidity({pool:{...i,tick_lower_index:t,tick_upper_index:u,current_sqrt_price:k==null?void 0:k.current_sqrt_price},position:{...T,liquidity:i.liquidity},roundUp:!1}),p=new o(v.coinaAmount).toNumber(),$=new o(v.coinbAmount).toNumber(),Z=L(new o(p).mul(new o(J)).toNumber(),2),j=L(new o($).mul(new o(E)).toNumber(),2),{ratioA:tt,ratioB:N}=G.calculateDepositRatio(t,u,new R.BN(k==null?void 0:k.current_sqrt_price)),U=tt.mul(100).toNumber().toFixed(0),V=100-Number(U);let Q=0;Number(P)>0&&(Q=new o(P).div(Math.pow(10,M.decimals)));const X=new o(c).add(new o(q)).toNumber(),K=J&&E?X>0&&X<.01?"<0.01":L(new o(c).add(new o(q)).toString(),2):"--",H=i.total_supply;let I=0;Q>0&&H>0&&(I=new o(Q).mul(Math.pow(10,M.decimals)).div(new o(H)).mul(100).toNumber());const W=new o(1).div(Math.pow(10,i.decimals)).toNumber();let Y=0;if(I>1)Y=L(I,2);else if(I>0&&I<W)Y=`<${W}`;else if(I==0)Y=0;else{const _t=At(I),bt=_t==-1?2:_t+2;Y=L(I,bt)}const ot=(await A.getTokenListByCoinType([i.quota_based_type]))[0],ut=nt(i.max_quota,ot.decimals),et=ot.address==i.coin_b_address,ct=et?new o(v.coinaAmount).mul(i.price).add(v.coinbAmount):new o(v.coinaAmount).mul(1/i.price).add(v.coinbAmount),st=((F=n[ot.address])==null?void 0:F.price)||"",it=ct.mul(new o(st)).toNumber(),mt=ut,St=et?new o(v.coinaAmount).mul(i.price).add(v.coinbAmount):new o(v.coinaAmount).mul(1/i.price).add(v.coinbAmount),qt=new o(mt).sub(St).mul(E).toNumber();this.positionInfoObj[i.id]={tick_lower_index:t,tick_upper_index:u,current_sqrt_price:k.current_sqrt_price,myLiquidity:nt(P,M.decimals),amountA:S,amountB:D,...i,lpInfo:M,myAmountAUSD:f,myAmountBUSD:y,myLiquidityUSD:K,myShare:Y,minPrice:g,maxPrice:B,poolCoinARatio:U,poolCoinBRatio:V,poolCoinANum:p,poolCoinBNum:$,poolCoinAUSD:Z,poolCoinBUSD:j,quoteUSD:mt,poolUSD:it,balance:P,quoteCoinInfo:ot,remainingTokenUSD:qt,currentDeposit:it,positionLiquidity:w},r.push({tick_lower_index:t,tick_upper_index:u,current_sqrt_price:(s=i==null?void 0:i.object)==null?void 0:s.current_sqrt_price,myLiquidity:nt(P,M.decimals),amountA:S,amountB:D,...i,lpInfo:M,myAmountAUSD:f,myAmountBUSD:y,myLiquidityUSD:K,myShare:Y,minPrice:g,maxPrice:B,poolCoinARatio:U,poolCoinBRatio:V,poolCoinANum:p,poolCoinBNum:$,poolCoinAUSD:Z,poolCoinBUSD:j,quoteUSD:mt,poolUSD:it,balance:P})}this.positionInfoList=r},async updatePositionItem(e){var ut,et,ct;const m=lt("Sui"),A=yt("Sui"),r=await m.getAutoPool(e),n=await A.getPool(r.pool_id),a={...this.positionInfoObj[e],autoPoolPositionInfo:r.positins[0],...n},O=await m.getLpBalance(a.lp_token_type),F=(await A.getTokenListByCoinType([a.lp_token_type]))[0],s=a.autoPoolPositionInfo.tick_lower_index,h=a.autoPoolPositionInfo.tick_upper_index,i=G.get_share_liquidity_by_amount({liquidity:r==null?void 0:r.liquidity,total_supply:r==null?void 0:r.total_supply},O),k={tick_lower_index:s,tick_upper_index:h,current_sqrt_price:n.current_sqrt_price,liquidity:i},P=A.getCoinAmountFromLiquidity({pool:{current_sqrt_price:n.current_sqrt_price,...a},position:k,roundUp:!1}),M=P.coinaAmount,J=P.coinbAmount,{RATES:E}=this.getPoolStore,t=r.total_supply,u=pt.sqrtPriceX64ToPrice(n.current_sqrt_price,a.coinA.decimals,a.coinB.decimals),w=2,T=2,C=((ut=E[a.coinA.address])==null?void 0:ut.price)||0,x=((et=E[a.coinB.address])==null?void 0:et.price)||0,b=new o(C).mul(new o(P==null?void 0:P.coinaAmount)).toNumber(),S=new o(x).mul(new o(P==null?void 0:P.coinbAmount)).toNumber(),D=b>0&&b<.01?"<$0.01":`$${at(L(b,2))}`,l=S>0&&S<.01?"<$0.01":`$${at(L(S,2))}`;let d=new o(0);Number(O)>0&&(d=new o(O).div(Math.pow(10,F.decimals)));const g=new o(b).add(new o(S)).toNumber(),B=C&&x?g>0&&g<.01?"<0.01":L(new o(b).add(new o(S)).toString(),2):"--",c=new o(d).mul(Math.pow(10,a.lpInfo.decimals)).div(new o(t)).mul(100).toNumber(),q=new o(1).div(Math.pow(10,a.decimals)).toNumber();let f=0;if(c>1)f=L(c,2);else if(c>0&&c<q)f=`<${q}`;else if(c==0)f=0;else{const st=At(c),it=st==-1?2:st+2;f=L(c,it)}pt.sqrtPriceX64ToPrice(n.current_sqrt_price,w,T);const y=await A.getCoinAmountFromLiquidity({pool:{...a,tick_lower_index:s,tick_upper_index:h,current_sqrt_price:n==null?void 0:n.current_sqrt_price},position:{...k,liquidity:r.liquidity},roundUp:!1}),v=new o(y.coinaAmount).toNumber(),p=new o(y.coinbAmount).toNumber(),$=L(new o(v).mul(new o(C)).toNumber(),2),Z=L(new o(p).mul(new o(x)).toNumber(),2),{ratioA:j,ratioB:tt}=G.calculateDepositRatio(s,h,new R.BN(n==null?void 0:n.current_sqrt_price)),N=j.mul(100).toNumber().toFixed(0),U=100-Number(N),V=(await A.getTokenListByCoinType([r.quota_based_type]))[0],Q=nt(r.max_quota,V.decimals),X=V.address==a.coin_b_address,K=X?new o(y.coinaAmount).mul(a.price).add(y.coinbAmount):new o(y.coinaAmount).mul(1/a.price).add(y.coinbAmount),H=((ct=E[V.address])==null?void 0:ct.price)||"",I=K.mul(new o(H)).toNumber(),W=Q,Y=X?new o(y.coinaAmount).mul(a.price).add(y.coinbAmount):new o(y.coinaAmount).mul(1/a.price).add(y.coinbAmount),ot=new o(W).sub(Y).mul(x).toNumber();this.positionInfoObj[e]={...a,tick_lower_index:s,tick_upper_index:h,current_sqrt_price:n.current_sqrt_price,myLiquidity:nt(O,F.decimals),amountA:M,amountB:J,myShare:f,myAmountAUSD:D,myAmountBUSD:l,myLiquidityUSD:B,poolCoinARatio:N,poolCoinBRatio:U,poolCoinANum:v,poolCoinBNum:p,poolCoinAUSD:$,poolCoinBUSD:Z,quoteUSD:W,balance:O,price:u,quoteCoinInfo:V,remainingTokenUSD:ot,currentDeposit:I,poolUSD:I,positionLiquidity:i,liquidity:r==null?void 0:r.liquidity}},async getAutoPoolAPY(){try{const{data:e}=await fetch(`${_.Sui.api}/v2/sui/auto_pools`).then(m=>m.json());e&&e.pools&&e.pools.length>0&&(this.apyObj=Object.fromEntries(e.pools.map((m,A)=>[m.object_id,{...m,apr:m.apr.replace("%","")>0&&m.apr.replace("%","")<.01?"<0.01%":L(m.apr.replace("%",""),2)+"%",resultApr:m.apr.replace("%","")}])))}catch{this.apyObj={}}},async getVault(e){const m=lt("Sui"),{status:A}=await m.getVault(e);this.currentAutoPoolStatus=A,this.updatePositionItem(e)},setSlippage(e){this.slippage=e,localStorage.setItem("cetus-auto-slippage",e)}}});export{lt as a,Ot as u};
