import{l as kt,R as Pt,a6 as ft}from"./entry.288d7d8a.js";import{c as l,a as Tt}from"./sha256.96c2da2e.js";import{P as xt,I as Bt,Q as qt,b as F,R as W,T as dt,C as wt,V as Y,q as At,s as v,u as ht,e as St,a as _t,f as gt,p as ut}from"./pool.9c8e0c93.js";import{D as e}from"./decimal.0bdeb344.js";function mt(i){const m={launchpad:l[i||"Sui"].launchpad,ido:l[i||"Sui"].ido,xcetus:l[i||"Sui"].xcetus,xcetus_dividends:l[i||"Sui"].xcetus_dividends,cetus_faucet:l[i||"Sui"].cetus_faucet,xtoken:l[i||"Sui"].xtoken,xtoken_dividends:l[i||"Sui"].xtoken_dividends,token_faucet:l[i||"Sui"].token_faucet,booster:l[i||"Sui"].booster,maker_bonus:l[i||"Sui"].maker_bonus,liquidity_stratefy:l[i||"Sui"].liquidity_stratefy,vaults:l[i||"Sui"].vaults,haedal:l[i||"Sui"].haedal,frams:l[i||"Sui"].frams},d={fullRpcUrl:localStorage.getItem(`${i}-currentRpclocal2`)||l[i||"Sui"].fullRpcUrl,simulationAccount:l[i||"Sui"].simulationAccount,cetus_config:l[i||"Sui"].cetus_config,clmm_pool:l[i||"Sui"].clmm_pool,integrate:l[i||"Sui"].integrate,deepbook:l[i||"Sui"].deepbook,deepbook_endpoint_v2:l[i||"Sui"].deepbook_endpoint_v2,aggregatorUrl:l[i||"Sui"].aggregatorUrl},_=new xt(d),n=new Bt(m,_),s=Tt(),$=kt(()=>s);Pt(()=>{$.value.address&&(_.senderAddress=$.value.address)});const R=async()=>{const o=await n.Vaults.getVaultList();return o&&o.data||[]},O=async o=>{const c=await n.Vaults.getVault(o);return{...c,quota_based_type:qt(c.quota_based_type).full_address}},u=async o=>{if(_.senderAddress){const c=await n.ClmmSDK.fullClient.getBalance({owner:_.senderAddress,coinType:o});return c&&c.totalBalance}else return 0},t=o=>({transactionBlock:o,options:{showEffects:!0,showEvents:!0,showInput:!0,showRawInput:!0,showObjectChanges:!0,showBalanceChanges:!0}});return{getAutoPools:R,getLpBalance:u,getVault:async o=>await n.Vaults.getVault(o),deposit:async o=>{const{lowerTick:c,upperTick:w,slippage:g,rewarder_coin_types:L,isOnlyA:f,isOnlyB:b,currentTickIndex:k,decimal_b:N,request_id:q,staking_id:U,shouldRequestStake:x,farming_pool:E}=o;let a=o.fix_amount_a,r,p,P,A=k;if(f||b){let B;try{B=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:o.curSqrtPrice,fix_amount_a:o.fix_amount_a,input_amount:o.coinAmount,coinTypeA:o.coinTypeA,coinTypeB:o.coinTypeB,clmm_pool:o.clmm_pool,use_route:!0,priceSplitPoint:g,request_id:q,staking_id:U,shouldRequestStake:x},!0)}catch{B=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:o.curSqrtPrice,fix_amount_a:o.fix_amount_a,input_amount:o.coinAmount,coinTypeA:o.coinTypeA,coinTypeB:o.coinTypeB,clmm_pool:o.clmm_pool,use_route:!1,priceSplitPoint:g,request_id:q,staking_id:U,shouldRequestStake:x},!0)}B?(p=new F(B.afterSqrtPrice),r=B.fixAmountA===a?new F(W(o.coinAmount).sub(B.swapInAmount).toString()):new F(B.swapOutAmount),P={swap_amount:B.swapInAmount,a2b:a,input_amount:o.coinAmount,route_obj:B.routeObj,staking_id:B.staking_id},a=B.fixAmountA,A=dt.sqrtPriceX64ToTickIndex(new F(B.afterSqrtPrice))):(p=new F(o.curSqrtPrice),r=new F(o.coinAmount))}else p=o.curSqrtPrice,r=new F(o.coinAmount);let D,j,M;A>=c&&A<=w?(D=wt.estLiquidityAndcoinAmountFromOneAmounts(c,w,r,a,!0,g,p),j=a?r.toString():D.tokenMaxA.toString(),M=a?D.tokenMaxB.toString():r.toString()):A<c?(j=r.toNumber(),M=0):A>w&&(j=0,M=r.toNumber());const z=await n.Vaults.deposit({lowerTick:c,upperTick:w,vault_id:o.id,clmm_pool:o.clmm_pool,lp_token_type:o.lp_token_type,amount_a:j,amount_b:M,fix_amount_a:a,slippage:g,coinTypeA:o.coinTypeA,coinTypeB:o.coinTypeB,swapParams:P,farming_pool:E});return t(z)},remove:async o=>{const{lowerTick:c,upperTick:w,coinTypeA:g,coinTypeB:L,receiveAmount:f,clmm_pool:b,lowerSqrtPrice:k,upperSqrtPrice:N,fix_amount_a:q,curSqrtPrice:U,slippage:x,rewarder_coin_types:E,id:a,liquidity:r,swapParams:p,isOnlyA:P,isOnlyB:A,sliderVal:D,positionInfo:j,maxLiquidity:M,request_id:z,farming_pool:B}=o,Q=await O(a),X=await _.Pool.getPool(Q.pool_id);let h,V,G,Z,J;const C=Y.get_share_liquidity_by_amount(Q,D==100?j.balance:o.lpTokenAmount);if(P||A){try{h=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:X.current_sqrt_price,fix_amount_a:q,receive_amount:f,coinTypeA:g,coinTypeB:L,clmm_pool:b,use_route:!0,priceSplitPoint:x,removeLiquidity:D==100?C:"",maxLiquidity:M,request_id:z})}catch{h=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:X.current_sqrt_price,fix_amount_a:q,receive_amount:f,coinTypeA:g,coinTypeB:L,clmm_pool:b,use_route:!1,priceSplitPoint:x,removeLiquidity:D==100?C:"",maxLiquidity:M,request_id:z})}if(h){const I=Y.get_share_liquidity_by_amount(Q,j.balance);V=wt.getCoinAmountFromLiquidity(new F(D==100?I:h.liquidity),new F(X.current_sqrt_price),k,N,!1),Y.get_protocol_fee_amount(Q,V.coinA.toString()),Y.get_protocol_fee_amount(Q,V.coinB.toString()),G=D==100?j.balance:Y.get_lp_amount_by_liquidity(Q,h.liquidity),Z=W(V.coinA.toString()).mul(W(1-o.slippage)),J=W(V.coinB.toString()).mul(W(1-o.slippage))}}else V=wt.getCoinAmountFromLiquidity(new F(C),new F(X.current_sqrt_price),k,N,!1),G=o.lpTokenAmount,Z=W(V.coinA.toString()).mul(W(1-o.slippage)),J=W(V.coinB.toString()).mul(W(1-o.slippage));const tt={vault_id:o.id,clmm_pool:o.clmm_pool,lp_token_type:o.lp_token_type,coinTypeA:o.coinTypeA,coinTypeB:o.coinTypeB,lp_token_amount:G,min_amount_a:At(Z,0)||"",min_amount_b:At(J,0)||"",rewarder_coin_types:[],slippage:o.slippage,farming_pool:B};(P||A)&&(tt.swapParams={a2b:!q,swap_amount:h==null?void 0:h.swapInAmount,route_obj:h.routeObj});const H=await n.Vaults.remove(tt);return t(H)},getAutoPool:O,calculateDepositSwapAmount:async o=>{const{lowerTick:c,upperTick:w,curSqrtPrice:g,fix_amount_a:L,input_amount:f,coinTypeA:b,coinTypeB:k,clmm_pool:N,slippage:q,decimals:U,request_id:x,staking_id:E,shouldRequestStake:a}=o;let r;try{r=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:g,fix_amount_a:L,input_amount:f,coinTypeA:b,coinTypeB:k,clmm_pool:N,use_route:!0,priceSplitPoint:q,request_id:x,staking_id:E,shouldRequestStake:a},!0)}catch(p){if(String(p)=="Error: route unavailable"&&(r=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:g,fix_amount_a:L,input_amount:f,coinTypeA:b,coinTypeB:k,clmm_pool:N,use_route:!1,priceSplitPoint:q,request_id:x,staking_id:E,shouldRequestStake:a},!0)),String(p)=="Error: HaedalStakeSuiAmountError")return"HaedalStakeSuiAmountError"}if(r){const p=new e(r.swapOutAmount);return{...r,swapOutAmountLimit:v(p.sub(p.mul(q)).toNumber(),U)}}return r},calculateRemoveSwapAmount:async o=>{const{lowerTick:c,upperTick:w,curSqrtPrice:g,fix_amount_a:L,receiveAmount:f,coinTypeA:b,coinTypeB:k,clmm_pool:N,slippage:q,decimals:U,liquidity:x,maxLiquidity:E,request_id:a}=o;let r;try{r=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:g,fix_amount_a:L,receive_amount:f,coinTypeA:b,coinTypeB:k,clmm_pool:N,use_route:!0,priceSplitPoint:q,removeLiquidity:x,maxLiquidity:E,request_id:a})}catch(p){String(p)=="Error: route unavailable"&&(r=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:g,fix_amount_a:L,receive_amount:f,coinTypeA:b,coinTypeB:k,clmm_pool:N,use_route:!1,priceSplitPoint:q,removeLiquidity:x,maxLiquidity:E,request_id:a}))}if(r){const p=new e(r.swapOutAmount);return{...r,swapOutAmountLimit:v(p.sub(p.mul(q)).toNumber(),U)}}return r}}}const Ct=ft("autoPool",{state:()=>({autoPoolList:[],autoPoolObj:{},positionInfoObj:{},positionInfoList:[],positionUSDObj:{},apyObj:{},currentAutoPoolStatus:"STATUS_RUNNING",slippage:localStorage.getItem("cetus-auto-slippage")||"0.1",autoPoolLoading:!1}),getters:{getPoolStore(){return ht()}},actions:{async getAutoPoolList(){const m=await mt("Sui").getAutoPools(),d=this.getPoolStore,_=l.Sui.vaultFilter,{data:n}=await fetch(`${l.Sui.api}/v2/sui/auto_pools`).then(u=>u.json()),s=(n==null?void 0:n.pools)||[],$=m.filter(u=>s.some(t=>t.object_id===u.id)),R=l.Sui.haedal.config.support_stakings,O=(_?$:m).map(u=>{var S;const t=d.poolConfigObj[u.pool_id],y=[t!=null&&t.needReverse?t==null?void 0:t.coin_b_address:t==null?void 0:t.coin_a_address,t!=null&&t.needReverse?t==null?void 0:t.coin_a_address:t==null?void 0:t.coin_b_address];return t==null||t.rewarderInfo.forEach(T=>{T.emissionsEveryDay>0&&y.push(T.coinAddress)}),(S=t==null?void 0:t.stable_farming)==null||S.stable_rewarder.forEach(T=>{T.amount_second>0&&y.push(T.coin)}),{...t,id:u.id,lp_token_type:u.lp_token_type,autoPoolPositionInfo:u.position,is_pause:u.is_pause,total_supply:u.total_supply,liquidity:u.liquidity,protocol_fee_rate:u.protocol_fee_rate,max_quota:u.max_quota,staking_id:u.staking_id,quota_based_type:qt(u.quota_based_type).full_address,supportHaedalStake:R.filter(T=>T.staking_id==u.staking_id).length>0,isTokenA:t!=null&&t.needReverse?(t==null?void 0:t.coin_b_address)=="0000000000000000000000000000000000000000000000000000000000000002::sui::SUI":(t==null?void 0:t.coin_a_address)=="0000000000000000000000000000000000000000000000000000000000000002::sui::SUI",rewardList:Array.from(new Set(y))}});this.autoPoolList=O,this.autoPoolObj=Object.fromEntries(O.map((u,t)=>[u.address,u])),this.getMyAutoPoolPosition()},async getMyAutoPoolPosition(){var s,$,R,O;const i=mt("Sui"),m=this.autoPoolList,d=St("Sui"),_=[],{RATES:n}=this.getPoolStore;for(let u=0;u<m.length;u++){const t=m[u],y=await d.getPool(t.address),S=await i.getLpBalance(m[u].lp_token_type),T=(await d.getTokenListByCoinType([m[u].lp_token_type]))[0],ot=((s=n[t.coinA.address])==null?void 0:s.price)||"",K=(($=n[t.coinB.address])==null?void 0:$.price)||"",o=t.autoPoolPositionInfo.tick_lower_index,c=t.autoPoolPositionInfo.tick_upper_index,w=Number(S)>0?Y.get_share_liquidity_by_amount({liquidity:t==null?void 0:t.liquidity,total_supply:t==null?void 0:t.total_supply},S):0,g={tick_lower_index:o,tick_upper_index:c,current_sqrt_price:y==null?void 0:y.current_sqrt_price,liquidity:w},L=await d.getCoinAmountFromLiquidity({pool:{...t,current_sqrt_price:y==null?void 0:y.current_sqrt_price},position:g,roundUp:!1}),f=L.coinaAmount,b=L.coinbAmount,k=f,N=b,q=t.coinA.decimals,U=t.coinB.decimals,x=d.TickMath.tickIndexToPrice(Number(o),q,U).toString(),E=d.TickMath.tickIndexToPrice(Number(c),q,U).toString(),a=new e(ot).mul(new e(f)).toNumber(),r=new e(K).mul(new e(b)).toNumber(),p=a>0&&a<.01?"<$0.01":`$${_t(v(a,2))}`,P=r>0&&r<.01?"<$0.01":`$${_t(v(r,2))}`;dt.sqrtPriceX64ToPrice(y.current_sqrt_price,q,U);const A=await d.getCoinAmountFromLiquidity({pool:{...t,tick_lower_index:o,tick_upper_index:c,current_sqrt_price:y==null?void 0:y.current_sqrt_price},position:{...g,liquidity:t.liquidity},roundUp:!1}),D=new e(A.coinaAmount).toNumber(),j=new e(A.coinbAmount).toNumber(),M=v(new e(D).mul(new e(ot)).toNumber(),2),z=v(new e(j).mul(new e(K)).toNumber(),2),{ratioA:B,ratioB:Q}=Y.calculateDepositRatio(o,c,new F.BN(y==null?void 0:y.current_sqrt_price)),X=B.mul(100).toNumber().toFixed(0),h=100-Number(X);let V=0;Number(S)>0&&(V=new e(S).div(Math.pow(10,T.decimals)));const G=new e(a).add(new e(r)).toNumber(),Z=ot&&K?G>0&&G<.01?"<0.01":v(new e(a).add(new e(r)).toString(),2):"--",J=t.total_supply;let C=0;V>0&&J>0&&(C=new e(V).mul(Math.pow(10,T.decimals)).div(new e(J)).mul(100).toNumber());const tt=new e(1).div(Math.pow(10,t.decimals)).toNumber();let H=0;if(C>1)H=v(C,2);else if(C>0&&C<tt)H=`<${tt}`;else if(C==0)H=0;else{const nt=gt(C),pt=nt==-1?2:nt+2;H=v(C,pt)}const I=(await d.getTokenListByCoinType([t.quota_based_type]))[0],yt=ut(t.max_quota,I.decimals),st=I.address==t.coin_b_address,rt=st?new e(A.coinaAmount).mul(t.price).add(A.coinbAmount):new e(A.coinaAmount).mul(1/t.price).add(A.coinbAmount),ct=((R=n[I.address])==null?void 0:R.price)||"",et=rt.mul(new e(ct)).toNumber(),it=yt,at=st?new e(A.coinaAmount).mul(t.price).add(A.coinbAmount):new e(A.coinaAmount).mul(1/t.price).add(A.coinbAmount),lt=new e(it).sub(at).mul(K).toNumber();this.positionInfoObj[t.id]={tick_lower_index:o,tick_upper_index:c,current_sqrt_price:y.current_sqrt_price,myLiquidity:ut(S,T.decimals),amountA:k,amountB:N,...t,lpInfo:T,myAmountAUSD:p,myAmountBUSD:P,myLiquidityUSD:Z,myShare:H,minPrice:x,maxPrice:E,poolCoinARatio:X,poolCoinBRatio:h,poolCoinANum:D,poolCoinBNum:j,poolCoinAUSD:M,poolCoinBUSD:z,quoteUSD:it,poolUSD:et,balance:S,quoteCoinInfo:I,remainingTokenUSD:lt,currentDeposit:et,positionLiquidity:w},_.push({tick_lower_index:o,tick_upper_index:c,current_sqrt_price:(O=t==null?void 0:t.object)==null?void 0:O.current_sqrt_price,myLiquidity:ut(S,T.decimals),amountA:k,amountB:N,...t,lpInfo:T,myAmountAUSD:p,myAmountBUSD:P,myLiquidityUSD:Z,myShare:H,minPrice:x,maxPrice:E,poolCoinARatio:X,poolCoinBRatio:h,poolCoinANum:D,poolCoinBNum:j,poolCoinAUSD:M,poolCoinBUSD:z,quoteUSD:it,poolUSD:et,balance:S})}this.positionInfoList=_},async updatePositionItem(i){var rt,ct,et,it,at,lt,nt;const m=mt("Sui"),d=St("Sui"),_=await m.getAutoPool(i),n=await d.getPool(_.pool_id),s={...this.positionInfoObj[i],autoPoolPositionInfo:_.position,...n},$=await m.getLpBalance(s.lp_token_type),R=(await d.getTokenListByCoinType([s.lp_token_type]))[0],O=s.autoPoolPositionInfo.tick_lower_index,u=s.autoPoolPositionInfo.tick_upper_index;let t;_.total_supply==0?t=0:t=Y.get_share_liquidity_by_amount(_,String($));const y={tick_lower_index:O,tick_upper_index:u,current_sqrt_price:n.current_sqrt_price,liquidity:t},S=d.getCoinAmountFromLiquidity({pool:{current_sqrt_price:n.current_sqrt_price,...s},position:y,roundUp:!1}),T=S.coinaAmount,ot=S.coinbAmount,{RATES:K}=this.getPoolStore,o=_.total_supply,c=dt.sqrtPriceX64ToPrice(n.current_sqrt_price,(rt=s==null?void 0:s.coinA)==null?void 0:rt.decimals,(ct=s==null?void 0:s.coinB)==null?void 0:ct.decimals),w=2,g=2,L=((it=K[(et=s==null?void 0:s.coinA)==null?void 0:et.address])==null?void 0:it.price)||0,f=((lt=K[(at=s==null?void 0:s.coinB)==null?void 0:at.address])==null?void 0:lt.price)||0,b=new e(L).mul(new e(S==null?void 0:S.coinaAmount)).toNumber(),k=new e(f).mul(new e(S==null?void 0:S.coinbAmount)).toNumber(),N=b>0&&b<.01?"<$0.01":`$${_t(v(b,2))}`,q=k>0&&k<.01?"<$0.01":`$${_t(v(k,2))}`;let U=new e(0);Number($)>0&&(U=new e($).div(Math.pow(10,R==null?void 0:R.decimals)));const x=new e(b).add(new e(k)).toNumber(),E=L&&f?x>0&&x<.01?"<0.01":v(new e(b).add(new e(k)).toString(),2):"--";let a=0;U.toNumber()>0&&o>0&&(a=new e(U).mul(Math.pow(10,R.decimals)).div(new e(o)).mul(100).toNumber());const r=new e(1).div(Math.pow(10,s.decimals)).toNumber();let p=0;if(a>1)p=v(a,2);else if(a>0&&a<r)p=`<${r}`;else if(a==0)p=0;else{const pt=gt(a),bt=pt==-1?2:pt+2;p=v(a,bt)}dt.sqrtPriceX64ToPrice(n.current_sqrt_price,w,g);const P=await d.getCoinAmountFromLiquidity({pool:{...s,tick_lower_index:O,tick_upper_index:u,current_sqrt_price:n==null?void 0:n.current_sqrt_price},position:{...y,liquidity:_.liquidity},roundUp:!1}),A=new e(P.coinaAmount).toNumber(),D=new e(P.coinbAmount).toNumber(),j=v(new e(A).mul(new e(L)).toNumber(),2),M=v(new e(D).mul(new e(f)).toNumber(),2),{ratioA:z,ratioB:B}=Y.calculateDepositRatio(O,u,new F.BN(n==null?void 0:n.current_sqrt_price)),Q=z.mul(100).toNumber().toFixed(0),X=100-Number(Q),h=(await d.getTokenListByCoinType([_.quota_based_type]))[0],V=ut(_.max_quota,h.decimals),G=h.address==s.coin_b_address,Z=G?new e(P.coinaAmount).mul(s.price).add(P.coinbAmount):new e(P.coinaAmount).mul(1/s.price).add(P.coinbAmount),J=((nt=K[h.address])==null?void 0:nt.price)||"",C=Z.mul(new e(J)).toNumber(),tt=V,H=G?new e(P.coinaAmount).mul(s.price).add(P.coinbAmount):new e(P.coinaAmount).mul(1/s.price).add(P.coinbAmount),I=new e(tt).sub(H).mul(f).toNumber(),yt=d.TickMath.tickIndexToPrice(Number(O),w,g).toString(),st=d.TickMath.tickIndexToPrice(Number(u),w,g).toString();this.positionInfoObj[i]={...s,tick_lower_index:O,tick_upper_index:u,current_sqrt_price:n.current_sqrt_price,myLiquidity:ut($,R==null?void 0:R.decimals),amountA:T,amountB:ot,myShare:p,myAmountAUSD:N,myAmountBUSD:q,myLiquidityUSD:E,poolCoinARatio:Q,poolCoinBRatio:X,poolCoinANum:A,poolCoinBNum:D,poolCoinAUSD:j,poolCoinBUSD:M,quoteUSD:tt,balance:$,price:c,quoteCoinInfo:h,remainingTokenUSD:I,currentDeposit:C,poolUSD:C,positionLiquidity:t,liquidity:_==null?void 0:_.liquidity,minPrice:yt,maxPrice:st},this.autoPoolLoading=!1},async getAutoPoolAPY(){try{const{data:i}=await fetch(`${l.Sui.api}/v2/sui/auto_pools`).then(m=>m.json());i&&i.pools&&i.pools.length>0&&(this.apyObj=Object.fromEntries(i.pools.map((m,d)=>[m.object_id,{...m,apr:m.apr.replace("%","")>0&&m.apr.replace("%","")<.01?"<0.01%":v(m.apr.replace("%",""),2)+"%",resultApr:m.apr.replace("%","")}])))}catch{this.apyObj={}}},async getVault(i,m){const d=mt("Sui");m||(this.autoPoolLoading=!0);const{status:_}=await d.getVault(i);this.currentAutoPoolStatus=_,this.updatePositionItem(i)},setSlippage(i){this.slippage=i,localStorage.setItem("cetus-auto-slippage",i)},logout(){this.getMyAutoPoolPosition(),this.positionUSDObj={}}}});export{mt as a,Ct as u};
