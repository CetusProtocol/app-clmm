import{a6 as ft,l as kt,R as Pt,a7 as Tt}from"./entry.7f57c35c.js";import{c as p,a as xt}from"./sha256.4b5cdcb3.js";import{P as Bt,I as vt,Q as qt,b as $,R as W,T as dt,C as At,V as Y,q as wt,s as v,u as ht,e as St,a as mt,f as gt,p as ut}from"./pool.3a232f6a.js";import{D as e}from"./decimal.0bdeb344.js";function _t(i){const d={launchpad:p[i||"Sui"].launchpad,ido:p[i||"Sui"].ido,xcetus:p[i||"Sui"].xcetus,xcetus_dividends:p[i||"Sui"].xcetus_dividends,cetus_faucet:p[i||"Sui"].cetus_faucet,xtoken:p[i||"Sui"].xtoken,xtoken_dividends:p[i||"Sui"].xtoken_dividends,token_faucet:p[i||"Sui"].token_faucet,booster:p[i||"Sui"].booster,maker_bonus:p[i||"Sui"].maker_bonus,liquidity_stratefy:p[i||"Sui"].liquidity_stratefy,vaults:p[i||"Sui"].vaults,haedal:p[i||"Sui"].haedal,frams:p[i||"Sui"].frams},y={fullRpcUrl:localStorage.getItem(`${i}-currentRpclocal2`)||p[i||"Sui"].fullRpcUrl,simulationAccount:p[i||"Sui"].simulationAccount,cetus_config:p[i||"Sui"].cetus_config,clmm_pool:p[i||"Sui"].clmm_pool,integrate:p[i||"Sui"].integrate,deepbook:p[i||"Sui"].deepbook,deepbook_endpoint_v2:p[i||"Sui"].deepbook_endpoint_v2,aggregatorUrl:p[i||"Sui"].aggregatorUrl},_=new Bt(y),n=ft(new vt(d,_)),s=xt(),V=kt(()=>s);Pt(()=>{V.value.address&&(_.senderAddress=V.value.address)});const U=async()=>{const t=await n.Vaults.getVaultList();return t&&t.data||[]},R=async t=>{const c=await n.Vaults.getVault(t);return{...c,quota_based_type:qt(c.quota_based_type).full_address}},u=async t=>{if(_.senderAddress){const c=await n.ClmmSDK.fullClient.getBalance({owner:_.senderAddress,coinType:t});return c&&c.totalBalance}else return 0},o=t=>({transactionBlock:t,options:{showEffects:!0,showEvents:!0,showInput:!0,showRawInput:!0,showObjectChanges:!0,showBalanceChanges:!0}});return{getAutoPools:U,getLpBalance:u,getVault:async t=>await n.Vaults.getVault(t),deposit:async t=>{const{lowerTick:c,upperTick:w,slippage:g,rewarder_coin_types:h,isOnlyA:P,isOnlyB:b,currentTickIndex:f,decimal_b:N,request_id:q,staking_id:D,shouldRequestStake:T,farming_pool:I}=t;let a=t.fix_amount_a,r,m,k,S=f;if(P||b){let x;try{x=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:t.curSqrtPrice,fix_amount_a:t.fix_amount_a,input_amount:t.coinAmount,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,clmm_pool:t.clmm_pool,use_route:!0,priceSplitPoint:g,request_id:q,staking_id:D,shouldRequestStake:T},!0)}catch{x=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:t.curSqrtPrice,fix_amount_a:t.fix_amount_a,input_amount:t.coinAmount,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,clmm_pool:t.clmm_pool,use_route:!1,priceSplitPoint:g,request_id:q,staking_id:D,shouldRequestStake:T},!0)}x?(m=new $(x.afterSqrtPrice),r=x.fixAmountA===a?new $(W(t.coinAmount).sub(x.swapInAmount).toString()):new $(x.swapOutAmount),k={swap_amount:x.swapInAmount,a2b:a,input_amount:t.coinAmount,route_obj:x.routeObj,staking_id:x.staking_id},a=x.fixAmountA,S=dt.sqrtPriceX64ToTickIndex(new $(x.afterSqrtPrice))):(m=new $(t.curSqrtPrice),r=new $(t.coinAmount))}else m=t.curSqrtPrice,r=new $(t.coinAmount);let L,O,E;S>=c&&S<=w?(L=At.estLiquidityAndcoinAmountFromOneAmounts(c,w,r,a,!0,g,m),O=a?r.toString():L.tokenMaxA.toString(),E=a?L.tokenMaxB.toString():r.toString()):S<c?(O=r.toNumber(),E=0):S>w&&(O=0,E=r.toNumber());const K=await n.Vaults.deposit({lowerTick:c,upperTick:w,vault_id:t.id,clmm_pool:t.clmm_pool,lp_token_type:t.lp_token_type,amount_a:O,amount_b:E,fix_amount_a:a,slippage:g,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,swapParams:k,farming_pool:I});return o(K)},remove:async t=>{const{lowerTick:c,upperTick:w,coinTypeA:g,coinTypeB:h,receiveAmount:P,clmm_pool:b,lowerSqrtPrice:f,upperSqrtPrice:N,fix_amount_a:q,curSqrtPrice:D,slippage:T,rewarder_coin_types:I,id:a,liquidity:r,swapParams:m,isOnlyA:k,isOnlyB:S,sliderVal:L,positionInfo:O,maxLiquidity:E,request_id:K,farming_pool:x}=t,F=await R(a),M=await _.Pool.getPool(F.pool_id);let B,j,z,Z,J;const C=Y.get_share_liquidity_by_amount(F,L==100?O.balance:t.lpTokenAmount);if(k||S){try{B=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:M.current_sqrt_price,fix_amount_a:q,receive_amount:P,coinTypeA:g,coinTypeB:h,clmm_pool:b,use_route:!0,priceSplitPoint:T,removeLiquidity:L==100?C:"",maxLiquidity:E,request_id:K})}catch{B=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:M.current_sqrt_price,fix_amount_a:q,receive_amount:P,coinTypeA:g,coinTypeB:h,clmm_pool:b,use_route:!1,priceSplitPoint:T,removeLiquidity:L==100?C:"",maxLiquidity:E,request_id:K})}if(B){const G=Y.get_share_liquidity_by_amount(F,O.balance);j=At.getCoinAmountFromLiquidity(new $(L==100?G:B.liquidity),new $(M.current_sqrt_price),f,N,!1),Y.get_protocol_fee_amount(F,j.coinA.toString()),Y.get_protocol_fee_amount(F,j.coinB.toString()),z=L==100?O.balance:Y.get_lp_amount_by_liquidity(F,B.liquidity),Z=W(j.coinA.toString()).mul(W(1-t.slippage)),J=W(j.coinB.toString()).mul(W(1-t.slippage))}}else j=At.getCoinAmountFromLiquidity(new $(C),new $(M.current_sqrt_price),f,N,!1),z=t.lpTokenAmount,Z=W(j.coinA.toString()).mul(W(1-t.slippage)),J=W(j.coinB.toString()).mul(W(1-t.slippage));const tt={vault_id:t.id,clmm_pool:t.clmm_pool,lp_token_type:t.lp_token_type,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,lp_token_amount:z,min_amount_a:wt(Z,0)||"",min_amount_b:wt(J,0)||"",rewarder_coin_types:[],slippage:t.slippage,farming_pool:x};(k||S)&&(tt.swapParams={a2b:!q,swap_amount:B==null?void 0:B.swapInAmount,route_obj:B.routeObj});const Q=await n.Vaults.remove(tt);return o(Q)},getAutoPool:R,calculateDepositSwapAmount:async t=>{const{lowerTick:c,upperTick:w,curSqrtPrice:g,fix_amount_a:h,input_amount:P,coinTypeA:b,coinTypeB:f,clmm_pool:N,slippage:q,decimals:D,request_id:T,staking_id:I,shouldRequestStake:a}=t;let r;try{r=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:g,fix_amount_a:h,input_amount:P,coinTypeA:b,coinTypeB:f,clmm_pool:N,use_route:!0,priceSplitPoint:q,request_id:T,staking_id:I,shouldRequestStake:a},!0)}catch(m){if(String(m)=="Error: route unavailable"&&(r=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:g,fix_amount_a:h,input_amount:P,coinTypeA:b,coinTypeB:f,clmm_pool:N,use_route:!1,priceSplitPoint:q,request_id:T,staking_id:I,shouldRequestStake:a},!0)),String(m)=="Error: HaedalStakeSuiAmountError")return"HaedalStakeSuiAmountError"}if(r){const m=new e(r.swapOutAmount);return{...r,swapOutAmountLimit:v(m.sub(m.mul(q)).toNumber(),D)}}return r},calculateRemoveSwapAmount:async t=>{const{lowerTick:c,upperTick:w,curSqrtPrice:g,fix_amount_a:h,receiveAmount:P,coinTypeA:b,coinTypeB:f,clmm_pool:N,slippage:q,decimals:D,liquidity:T,maxLiquidity:I,request_id:a}=t;let r;try{r=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:g,fix_amount_a:h,receive_amount:P,coinTypeA:b,coinTypeB:f,clmm_pool:N,use_route:!0,priceSplitPoint:q,removeLiquidity:T,maxLiquidity:I,request_id:a})}catch(m){String(m)=="Error: route unavailable"&&(r=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:w,curSqrtPrice:g,fix_amount_a:h,receive_amount:P,coinTypeA:b,coinTypeB:f,clmm_pool:N,use_route:!1,priceSplitPoint:q,removeLiquidity:T,maxLiquidity:I,request_id:a}))}if(r){const m=new e(r.swapOutAmount);return{...r,swapOutAmountLimit:v(m.sub(m.mul(q)).toNumber(),D)}}return r}}}const Rt=Tt("autoPool",{state:()=>({autoPoolList:[],autoPoolObj:{},positionInfoObj:{},positionInfoList:[],positionUSDObj:{},apyObj:{},currentAutoPoolStatus:"STATUS_RUNNING",slippage:localStorage.getItem("cetus-auto-slippage")||"0.1",autoPoolLoading:!1}),getters:{getPoolStore(){return ht()}},actions:{async getAutoPoolList(){const d=await _t("Sui").getAutoPools(),y=this.getPoolStore,_=p.Sui.vaultFilter,{data:n}=await fetch(`${p.Sui.api}/v2/sui/auto_pools`).then(u=>u.json()),s=(n==null?void 0:n.pools)||[],V=d.filter(u=>s.some(o=>o.object_id===u.id)),U=p.Sui.haedal.config.support_stakings,R=(_?V:d).map(u=>{const o=y.poolConfigObj[u.pool_id],A=[o!=null&&o.needReverse?o.coinB.address:o.coinA.address,o!=null&&o.needReverse?o.coinA.address:o.coinB.address];return o.rewarderInfo.forEach(l=>{l.emissionsEveryDay>0&&A.push(l.coinAddress)}),o.stable_farming.stable_rewarder.forEach(l=>{l.amount_second>0&&A.push(l.coin)}),{...o,id:u.id,lp_token_type:u.lp_token_type,autoPoolPositionInfo:u.position,is_pause:u.is_pause,total_supply:u.total_supply,liquidity:u.liquidity,protocol_fee_rate:u.protocol_fee_rate,max_quota:u.max_quota,staking_id:u.staking_id,quota_based_type:qt(u.quota_based_type).full_address,supportHaedalStake:U.filter(l=>l.staking_id==u.staking_id).length>0,isTokenA:o.needReverse?o.coin_b_address=="0000000000000000000000000000000000000000000000000000000000000002::sui::SUI":o.coin_a_address=="0000000000000000000000000000000000000000000000000000000000000002::sui::SUI",rewardList:Array.from(new Set(A))}});this.autoPoolList=R,this.autoPoolObj=Object.fromEntries(R.map((u,o)=>[u.address,u])),this.getMyAutoPoolPosition()},async getMyAutoPoolPosition(){var s,V,U,R;const i=_t("Sui"),d=this.autoPoolList,y=St("Sui"),_=[],{RATES:n}=this.getPoolStore;for(let u=0;u<d.length;u++){const o=d[u],A=await y.getPool(o.address),l=await i.getLpBalance(d[u].lp_token_type),X=(await y.getTokenListByCoinType([d[u].lp_token_type]))[0],ot=((s=n[o.coinA.address])==null?void 0:s.price)||"",H=((V=n[o.coinB.address])==null?void 0:V.price)||"",t=o.autoPoolPositionInfo.tick_lower_index,c=o.autoPoolPositionInfo.tick_upper_index,w=Number(l)>0?Y.get_share_liquidity_by_amount({liquidity:o==null?void 0:o.liquidity,total_supply:o==null?void 0:o.total_supply},l):0,g={tick_lower_index:t,tick_upper_index:c,current_sqrt_price:A==null?void 0:A.current_sqrt_price,liquidity:w},h=await y.getCoinAmountFromLiquidity({pool:{...o,current_sqrt_price:A==null?void 0:A.current_sqrt_price},position:g,roundUp:!1}),P=h.coinaAmount,b=h.coinbAmount,f=P,N=b,q=o.coinA.decimals,D=o.coinB.decimals,T=y.TickMath.tickIndexToPrice(Number(t),q,D).toString(),I=y.TickMath.tickIndexToPrice(Number(c),q,D).toString(),a=new e(ot).mul(new e(P)).toNumber(),r=new e(H).mul(new e(b)).toNumber(),m=a>0&&a<.01?"<$0.01":`$${mt(v(a,2))}`,k=r>0&&r<.01?"<$0.01":`$${mt(v(r,2))}`;dt.sqrtPriceX64ToPrice(A.current_sqrt_price,q,D);const S=await y.getCoinAmountFromLiquidity({pool:{...o,tick_lower_index:t,tick_upper_index:c,current_sqrt_price:A==null?void 0:A.current_sqrt_price},position:{...g,liquidity:o.liquidity},roundUp:!1}),L=new e(S.coinaAmount).toNumber(),O=new e(S.coinbAmount).toNumber(),E=v(new e(L).mul(new e(ot)).toNumber(),2),K=v(new e(O).mul(new e(H)).toNumber(),2),{ratioA:x,ratioB:F}=Y.calculateDepositRatio(t,c,new $.BN(A==null?void 0:A.current_sqrt_price)),M=x.mul(100).toNumber().toFixed(0),B=100-Number(M);let j=0;Number(l)>0&&(j=new e(l).div(Math.pow(10,X.decimals)));const z=new e(a).add(new e(r)).toNumber(),Z=ot&&H?z>0&&z<.01?"<0.01":v(new e(a).add(new e(r)).toString(),2):"--",J=o.total_supply;let C=0;j>0&&J>0&&(C=new e(j).mul(Math.pow(10,X.decimals)).div(new e(J)).mul(100).toNumber());const tt=new e(1).div(Math.pow(10,o.decimals)).toNumber();let Q=0;if(C>1)Q=v(C,2);else if(C>0&&C<tt)Q=`<${tt}`;else if(C==0)Q=0;else{const nt=gt(C),pt=nt==-1?2:nt+2;Q=v(C,pt)}const G=(await y.getTokenListByCoinType([o.quota_based_type]))[0],yt=ut(o.max_quota,G.decimals),st=G.address==o.coin_b_address,rt=st?new e(S.coinaAmount).mul(o.price).add(S.coinbAmount):new e(S.coinaAmount).mul(1/o.price).add(S.coinbAmount),ct=((U=n[G.address])==null?void 0:U.price)||"",et=rt.mul(new e(ct)).toNumber(),it=yt,at=st?new e(S.coinaAmount).mul(o.price).add(S.coinbAmount):new e(S.coinaAmount).mul(1/o.price).add(S.coinbAmount),lt=new e(it).sub(at).mul(H).toNumber();this.positionInfoObj[o.id]={tick_lower_index:t,tick_upper_index:c,current_sqrt_price:A.current_sqrt_price,myLiquidity:ut(l,X.decimals),amountA:f,amountB:N,...o,lpInfo:X,myAmountAUSD:m,myAmountBUSD:k,myLiquidityUSD:Z,myShare:Q,minPrice:T,maxPrice:I,poolCoinARatio:M,poolCoinBRatio:B,poolCoinANum:L,poolCoinBNum:O,poolCoinAUSD:E,poolCoinBUSD:K,quoteUSD:it,poolUSD:et,balance:l,quoteCoinInfo:G,remainingTokenUSD:lt,currentDeposit:et,positionLiquidity:w},_.push({tick_lower_index:t,tick_upper_index:c,current_sqrt_price:(R=o==null?void 0:o.object)==null?void 0:R.current_sqrt_price,myLiquidity:ut(l,X.decimals),amountA:f,amountB:N,...o,lpInfo:X,myAmountAUSD:m,myAmountBUSD:k,myLiquidityUSD:Z,myShare:Q,minPrice:T,maxPrice:I,poolCoinARatio:M,poolCoinBRatio:B,poolCoinANum:L,poolCoinBNum:O,poolCoinAUSD:E,poolCoinBUSD:K,quoteUSD:it,poolUSD:et,balance:l})}this.positionInfoList=_},async updatePositionItem(i){var rt,ct,et,it,at,lt,nt;const d=_t("Sui"),y=St("Sui"),_=await d.getAutoPool(i),n=await y.getPool(_.pool_id),s={...this.positionInfoObj[i],autoPoolPositionInfo:_.position,...n},V=await d.getLpBalance(s.lp_token_type),U=(await y.getTokenListByCoinType([s.lp_token_type]))[0],R=s.autoPoolPositionInfo.tick_lower_index,u=s.autoPoolPositionInfo.tick_upper_index;let o;_.total_supply==0?o=0:o=Y.get_share_liquidity_by_amount(_,String(V));const A={tick_lower_index:R,tick_upper_index:u,current_sqrt_price:n.current_sqrt_price,liquidity:o},l=y.getCoinAmountFromLiquidity({pool:{current_sqrt_price:n.current_sqrt_price,...s},position:A,roundUp:!1}),X=l.coinaAmount,ot=l.coinbAmount,{RATES:H}=this.getPoolStore,t=_.total_supply,c=dt.sqrtPriceX64ToPrice(n.current_sqrt_price,(rt=s==null?void 0:s.coinA)==null?void 0:rt.decimals,(ct=s==null?void 0:s.coinB)==null?void 0:ct.decimals),w=2,g=2,h=((it=H[(et=s==null?void 0:s.coinA)==null?void 0:et.address])==null?void 0:it.price)||0,P=((lt=H[(at=s==null?void 0:s.coinB)==null?void 0:at.address])==null?void 0:lt.price)||0,b=new e(h).mul(new e(l==null?void 0:l.coinaAmount)).toNumber(),f=new e(P).mul(new e(l==null?void 0:l.coinbAmount)).toNumber(),N=b>0&&b<.01?"<$0.01":`$${mt(v(b,2))}`,q=f>0&&f<.01?"<$0.01":`$${mt(v(f,2))}`;let D=new e(0);Number(V)>0&&(D=new e(V).div(Math.pow(10,U==null?void 0:U.decimals)));const T=new e(b).add(new e(f)).toNumber(),I=h&&P?T>0&&T<.01?"<0.01":v(new e(b).add(new e(f)).toString(),2):"--";let a=0;D.toNumber()>0&&t>0&&(a=new e(D).mul(Math.pow(10,U.decimals)).div(new e(t)).mul(100).toNumber());const r=new e(1).div(Math.pow(10,s.decimals)).toNumber();let m=0;if(a>1)m=v(a,2);else if(a>0&&a<r)m=`<${r}`;else if(a==0)m=0;else{const pt=gt(a),bt=pt==-1?2:pt+2;m=v(a,bt)}dt.sqrtPriceX64ToPrice(n.current_sqrt_price,w,g);const k=await y.getCoinAmountFromLiquidity({pool:{...s,tick_lower_index:R,tick_upper_index:u,current_sqrt_price:n==null?void 0:n.current_sqrt_price},position:{...A,liquidity:_.liquidity},roundUp:!1}),S=new e(k.coinaAmount).toNumber(),L=new e(k.coinbAmount).toNumber(),O=v(new e(S).mul(new e(h)).toNumber(),2),E=v(new e(L).mul(new e(P)).toNumber(),2),{ratioA:K,ratioB:x}=Y.calculateDepositRatio(R,u,new $.BN(n==null?void 0:n.current_sqrt_price)),F=K.mul(100).toNumber().toFixed(0),M=100-Number(F),B=(await y.getTokenListByCoinType([_.quota_based_type]))[0],j=ut(_.max_quota,B.decimals),z=B.address==s.coin_b_address,Z=z?new e(k.coinaAmount).mul(s.price).add(k.coinbAmount):new e(k.coinaAmount).mul(1/s.price).add(k.coinbAmount),J=((nt=H[B.address])==null?void 0:nt.price)||"",C=Z.mul(new e(J)).toNumber(),tt=j,Q=z?new e(k.coinaAmount).mul(s.price).add(k.coinbAmount):new e(k.coinaAmount).mul(1/s.price).add(k.coinbAmount),G=new e(tt).sub(Q).mul(P).toNumber(),yt=y.TickMath.tickIndexToPrice(Number(R),w,g).toString(),st=y.TickMath.tickIndexToPrice(Number(u),w,g).toString();this.positionInfoObj[i]={...s,tick_lower_index:R,tick_upper_index:u,current_sqrt_price:n.current_sqrt_price,myLiquidity:ut(V,U==null?void 0:U.decimals),amountA:X,amountB:ot,myShare:m,myAmountAUSD:N,myAmountBUSD:q,myLiquidityUSD:I,poolCoinARatio:F,poolCoinBRatio:M,poolCoinANum:S,poolCoinBNum:L,poolCoinAUSD:O,poolCoinBUSD:E,quoteUSD:tt,balance:V,price:c,quoteCoinInfo:B,remainingTokenUSD:G,currentDeposit:C,poolUSD:C,positionLiquidity:o,liquidity:_==null?void 0:_.liquidity,minPrice:yt,maxPrice:st},this.autoPoolLoading=!1},async getAutoPoolAPY(){try{const{data:i}=await fetch(`${p.Sui.api}/v2/sui/auto_pools`).then(d=>d.json());i&&i.pools&&i.pools.length>0&&(this.apyObj=Object.fromEntries(i.pools.map((d,y)=>[d.object_id,{...d,apr:d.apr.replace("%","")>0&&d.apr.replace("%","")<.01?"<0.01%":v(d.apr.replace("%",""),2)+"%",resultApr:d.apr.replace("%","")}])))}catch{this.apyObj={}}},async getVault(i,d){const y=_t("Sui");d||(this.autoPoolLoading=!0);const{status:_}=await y.getVault(i);this.currentAutoPoolStatus=_,this.updatePositionItem(i)},setSlippage(i){this.slippage=i,localStorage.setItem("cetus-auto-slippage",i)}}});export{_t as a,Rt as u};
