import{a6 as Pt,l as kt,R as Tt,a7 as xt}from"./entry.8244466d.js";import{c as _,a as Bt}from"./sha256.723c3cf0.js";import{P as vt,I as Lt,Q as gt,b as V,R as z,T as yt,C as mt,V as G,q as St,s as h,u as ht,e as qt,a as _t,f as bt,p as ut}from"./pool.daa43b66.js";import{D as o}from"./decimal.0bdeb344.js";function dt(e){const m={launchpad:_[e||"Sui"].launchpad,ido:_[e||"Sui"].ido,xcetus:_[e||"Sui"].xcetus,xcetus_dividends:_[e||"Sui"].xcetus_dividends,cetus_faucet:_[e||"Sui"].cetus_faucet,xtoken:_[e||"Sui"].xtoken,xtoken_dividends:_[e||"Sui"].xtoken_dividends,token_faucet:_[e||"Sui"].token_faucet,booster:_[e||"Sui"].booster,maker_bonus:_[e||"Sui"].maker_bonus,liquidity_stratefy:_[e||"Sui"].liquidity_stratefy,vaults:_[e||"Sui"].vaults},d={fullRpcUrl:localStorage.getItem(`${e}-currentRpclocal2`)||_[e||"Sui"].fullRpcUrl,simulationAccount:_[e||"Sui"].simulationAccount,cetus_config:_[e||"Sui"].cetus_config,clmm_pool:_[e||"Sui"].clmm_pool,integrate:_[e||"Sui"].integrate,deepbook:_[e||"Sui"].deepbook,deepbook_endpoint_v2:_[e||"Sui"].deepbook_endpoint_v2,aggregatorUrl:_[e||"Sui"].aggregatorUrl},a=new vt(d),n=Pt(new Lt(m,a)),u=Bt(),O=kt(()=>u);Tt(()=>{O.value.address&&(a.senderAddress=O.value.address)});const N=async()=>{const t=await n.Vaults.getVaultList();return t&&t.data||[]},s=async t=>{const c=await n.Vaults.getVault(t);return{...c,quota_based_type:gt(c.quota_based_type).full_address}},L=async t=>{if(a.senderAddress){const c=await n.ClmmSDK.fullClient.getBalance({owner:a.senderAddress,coinType:t});return c&&c.totalBalance}else return 0},i=t=>({transactionBlock:t,options:{showEffects:!0,showEvents:!0,showInput:!0,showRawInput:!0,showObjectChanges:!0,showBalanceChanges:!0}});return{getAutoPools:N,getLpBalance:L,getVault:async t=>await n.Vaults.getVault(t),deposit:async t=>{const{lowerTick:c,upperTick:y,slippage:S,rewarder_coin_types:D,isOnlyA:x,isOnlyB:g,currentTickIndex:q,decimal_b:C}=t;let l=t.fix_amount_a,A,f,B,r=q;if(x||g){let p;try{p=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:y,curSqrtPrice:t.curSqrtPrice,fix_amount_a:t.fix_amount_a,input_amount:t.coinAmount,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,clmm_pool:t.clmm_pool,use_route:!0,priceSplitPoint:S},!0)}catch{p=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:y,curSqrtPrice:t.curSqrtPrice,fix_amount_a:t.fix_amount_a,input_amount:t.coinAmount,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,clmm_pool:t.clmm_pool,use_route:!1,priceSplitPoint:S},!0)}p?(f=new V(p.afterSqrtPrice),A=p.fixAmountA===l?new V(z(t.coinAmount).sub(p.swapInAmount).toString()):new V(p.swapOutAmount),B={swap_amount:p.swapInAmount,a2b:l,input_amount:t.coinAmount,route_obj:p.routeObj},l=p.fixAmountA,r=yt.sqrtPriceX64ToTickIndex(new V(p.afterSqrtPrice))):(f=new V(t.curSqrtPrice),A=new V(t.coinAmount))}else f=t.curSqrtPrice,A=new V(t.coinAmount);let b,P,w;r>=c&&r<=y?(b=mt.estLiquidityAndcoinAmountFromOneAmounts(c,y,A,l,!0,S,f),P=l?A.toString():b.tokenMaxA.toString(),w=l?b.tokenMaxB.toString():A.toString()):r<c?(P=A.toNumber(),w=0):r>y&&(P=0,w=A.toNumber());const v=await n.Vaults.deposit({lowerTick:c,upperTick:y,vault_id:t.id,clmm_pool:t.clmm_pool,lp_token_type:t.lp_token_type,amount_a:P,amount_b:w,fix_amount_a:l,slippage:S,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,swapParams:B});return i(v)},remove:async t=>{const{lowerTick:c,upperTick:y,coinTypeA:S,coinTypeB:D,receiveAmount:x,clmm_pool:g,lowerSqrtPrice:q,upperSqrtPrice:C,fix_amount_a:l,curSqrtPrice:A,slippage:f,rewarder_coin_types:B,id:r,liquidity:b,swapParams:P,isOnlyA:w,isOnlyB:v,sliderVal:p,positionInfo:$,maxLiquidity:Z}=t,I=await s(r),tt=await a.Pool.getPool(I.pool_id);let R,U,F,Q,X;const K=G.get_share_liquidity_by_amount(I,p==100?$.balance:t.lpTokenAmount);if(w||v){try{R=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:y,curSqrtPrice:tt.current_sqrt_price,fix_amount_a:l,receive_amount:x,coinTypeA:S,coinTypeB:D,clmm_pool:g,use_route:!0,priceSplitPoint:f,removeLiquidity:p==100?K:"",maxLiquidity:Z})}catch{R=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:y,curSqrtPrice:tt.current_sqrt_price,fix_amount_a:l,receive_amount:x,coinTypeA:S,coinTypeB:D,clmm_pool:g,use_route:!1,priceSplitPoint:f,removeLiquidity:p==100?K:"",maxLiquidity:Z})}if(R){const W=G.get_share_liquidity_by_amount(I,$.balance);U=mt.getCoinAmountFromLiquidity(new V(p==100?W:R.liquidity),new V(tt.current_sqrt_price),q,C,!1),G.get_protocol_fee_amount(I,U.coinA.toString()),G.get_protocol_fee_amount(I,U.coinB.toString()),F=p==100?$.balance:G.get_lp_amount_by_liquidity(I,R.liquidity),Q=z(U.coinA.toString()).mul(z(1-t.slippage)),X=z(U.coinB.toString()).mul(z(1-t.slippage))}}else U=mt.getCoinAmountFromLiquidity(new V(K),A,q,C,!1),U=mt.getCoinAmountFromLiquidity(new V(K),A,q,C,!1),F=t.lpTokenAmount,Q=z(U.coinA.toString()).mul(z(1-t.slippage)),X=z(U.coinB.toString()).mul(z(1-t.slippage));const H={vault_id:t.id,clmm_pool:t.clmm_pool,lp_token_type:t.lp_token_type,coinTypeA:t.coinTypeA,coinTypeB:t.coinTypeB,lp_token_amount:F,min_amount_a:St(Q,0)||"",min_amount_b:St(X,0)||"",rewarder_coin_types:[],slippage:t.slippage};(w||v)&&(H.swapParams={a2b:!l,swap_amount:R==null?void 0:R.swapInAmount,route_obj:R.routeObj});const j=await n.Vaults.remove(H);return i(j)},getAutoPool:s,calculateDepositSwapAmount:async t=>{const{lowerTick:c,upperTick:y,curSqrtPrice:S,fix_amount_a:D,input_amount:x,coinTypeA:g,coinTypeB:q,clmm_pool:C,slippage:l,decimals:A,request_id:f}=t;let B;try{B=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:y,curSqrtPrice:S,fix_amount_a:D,input_amount:x,coinTypeA:g,coinTypeB:q,clmm_pool:C,use_route:!0,priceSplitPoint:l,request_id:f},!0)}catch(r){String(r)=="Error: route unavailable"&&(B=await n.Vaults.calculateDepositSwapAmount({lowerTick:c,upperTick:y,curSqrtPrice:S,fix_amount_a:D,input_amount:x,coinTypeA:g,coinTypeB:q,clmm_pool:C,use_route:!1,priceSplitPoint:l,request_id:f},!0))}if(B){const r=new o(B.swapOutAmount);return{...B,swapOutAmountLimit:h(r.sub(r.mul(l)).toNumber(),A)}}return B},calculateRemoveSwapAmount:async t=>{const{lowerTick:c,upperTick:y,curSqrtPrice:S,fix_amount_a:D,receiveAmount:x,coinTypeA:g,coinTypeB:q,clmm_pool:C,slippage:l,decimals:A,liquidity:f,maxLiquidity:B,request_id:r}=t;let b;try{b=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:y,curSqrtPrice:S,fix_amount_a:D,receive_amount:x,coinTypeA:g,coinTypeB:q,clmm_pool:C,use_route:!0,priceSplitPoint:l,removeLiquidity:f,maxLiquidity:B,request_id:r})}catch(P){String(P)=="Error: route unavailable"&&(b=await n.Vaults.calculateRemoveSwapAmount({lowerTick:c,upperTick:y,curSqrtPrice:S,fix_amount_a:D,receive_amount:x,coinTypeA:g,coinTypeB:q,clmm_pool:C,use_route:!1,priceSplitPoint:l,removeLiquidity:f,maxLiquidity:B,request_id:r}))}if(b){const P=new o(b.swapOutAmount);return{...b,swapOutAmountLimit:h(P.sub(P.mul(l)).toNumber(),A)}}return b}}}const Ot=xt("autoPool",{state:()=>({autoPoolList:[],autoPoolObj:{},positionInfoObj:{},positionInfoList:[],positionUSDObj:{},apyObj:{},currentAutoPoolStatus:"STATUS_RUNNING",slippage:localStorage.getItem("cetus-auto-slippage")||"0.1",autoPoolLoading:!1}),getters:{getPoolStore(){return ht()}},actions:{async getAutoPoolList(){const m=await dt("Sui").getAutoPools(),d=this.getPoolStore,a=_.Sui.vaultFilter,{data:n}=await fetch(`${_.Sui.api}/v2/sui/auto_pools`).then(s=>s.json()),u=(n==null?void 0:n.pools)||[],O=m.filter(s=>u.some(L=>L.object_id===s.id)),N=(a?O:m).map(s=>({...d.poolConfigObj[s.pool_id],id:s.id,lp_token_type:s.lp_token_type,autoPoolPositionInfo:s.positins[0],is_pause:s.is_pause,total_supply:s.total_supply,liquidity:s.liquidity,protocol_fee_rate:s.protocol_fee_rate,max_quota:s.max_quota,quota_based_type:gt(s.quota_based_type).full_address}));this.autoPoolList=N,this.autoPoolObj=Object.fromEntries(N.map((s,L)=>[s.address,s])),this.getMyAutoPoolPosition()},async getMyAutoPoolPosition(){var u,O,N,s;const e=dt("Sui"),m=this.autoPoolList,d=qt("Sui"),a=[],{RATES:n}=this.getPoolStore;for(let L=0;L<m.length;L++){const i=m[L],k=await d.getPool(i.address),T=await e.getLpBalance(m[L].lp_token_type),M=(await d.getTokenListByCoinType([m[L].lp_token_type]))[0],J=((u=n[i.coinA.address])==null?void 0:u.price)||"",E=((O=n[i.coinB.address])==null?void 0:O.price)||"",t=i.autoPoolPositionInfo.tick_lower_index,c=i.autoPoolPositionInfo.tick_upper_index,y=Number(T)>0?G.get_share_liquidity_by_amount({liquidity:i==null?void 0:i.liquidity,total_supply:i==null?void 0:i.total_supply},T):0,S={tick_lower_index:t,tick_upper_index:c,current_sqrt_price:k==null?void 0:k.current_sqrt_price,liquidity:y},D=await d.getCoinAmountFromLiquidity({pool:{...i,current_sqrt_price:k==null?void 0:k.current_sqrt_price},position:S,roundUp:!1}),x=D.coinaAmount,g=D.coinbAmount,q=x,C=g,l=i.coinA.decimals,A=i.coinB.decimals,f=d.TickMath.tickIndexToPrice(Number(t),l,A).toString(),B=d.TickMath.tickIndexToPrice(Number(c),l,A).toString(),r=new o(J).mul(new o(x)).toNumber(),b=new o(E).mul(new o(g)).toNumber(),P=r>0&&r<.01?"<$0.01":`$${_t(h(r,2))}`,w=b>0&&b<.01?"<$0.01":`$${_t(h(b,2))}`;yt.sqrtPriceX64ToPrice(k.current_sqrt_price,l,A);const v=await d.getCoinAmountFromLiquidity({pool:{...i,tick_lower_index:t,tick_upper_index:c,current_sqrt_price:k==null?void 0:k.current_sqrt_price},position:{...S,liquidity:i.liquidity},roundUp:!1}),p=new o(v.coinaAmount).toNumber(),$=new o(v.coinbAmount).toNumber(),Z=h(new o(p).mul(new o(J)).toNumber(),2),I=h(new o($).mul(new o(E)).toNumber(),2),{ratioA:tt,ratioB:R}=G.calculateDepositRatio(t,c,new V.BN(k==null?void 0:k.current_sqrt_price)),U=tt.mul(100).toNumber().toFixed(0),F=100-Number(U);let Q=0;Number(T)>0&&(Q=new o(T).div(Math.pow(10,M.decimals)));const X=new o(r).add(new o(b)).toNumber(),K=J&&E?X>0&&X<.01?"<0.01":h(new o(r).add(new o(b)).toString(),2):"--",H=i.total_supply;let j=0;Q>0&&H>0&&(j=new o(Q).mul(Math.pow(10,M.decimals)).div(new o(H)).mul(100).toNumber());const W=new o(1).div(Math.pow(10,i.decimals)).toNumber();let Y=0;if(j>1)Y=h(j,2);else if(j>0&&j<W)Y=`<${W}`;else if(j==0)Y=0;else{const nt=bt(j),pt=nt==-1?2:nt+2;Y=h(j,pt)}const ot=(await d.getTokenListByCoinType([i.quota_based_type]))[0],At=ut(i.max_quota,ot.decimals),ct=ot.address==i.coin_b_address,st=ct?new o(v.coinaAmount).mul(i.price).add(v.coinbAmount):new o(v.coinaAmount).mul(1/i.price).add(v.coinbAmount),rt=((N=n[ot.address])==null?void 0:N.price)||"",et=st.mul(new o(rt)).toNumber(),it=At,at=ct?new o(v.coinaAmount).mul(i.price).add(v.coinbAmount):new o(v.coinaAmount).mul(1/i.price).add(v.coinbAmount),lt=new o(it).sub(at).mul(E).toNumber();this.positionInfoObj[i.id]={tick_lower_index:t,tick_upper_index:c,current_sqrt_price:k.current_sqrt_price,myLiquidity:ut(T,M.decimals),amountA:q,amountB:C,...i,lpInfo:M,myAmountAUSD:P,myAmountBUSD:w,myLiquidityUSD:K,myShare:Y,minPrice:f,maxPrice:B,poolCoinARatio:U,poolCoinBRatio:F,poolCoinANum:p,poolCoinBNum:$,poolCoinAUSD:Z,poolCoinBUSD:I,quoteUSD:it,poolUSD:et,balance:T,quoteCoinInfo:ot,remainingTokenUSD:lt,currentDeposit:et,positionLiquidity:y},a.push({tick_lower_index:t,tick_upper_index:c,current_sqrt_price:(s=i==null?void 0:i.object)==null?void 0:s.current_sqrt_price,myLiquidity:ut(T,M.decimals),amountA:q,amountB:C,...i,lpInfo:M,myAmountAUSD:P,myAmountBUSD:w,myLiquidityUSD:K,myShare:Y,minPrice:f,maxPrice:B,poolCoinARatio:U,poolCoinBRatio:F,poolCoinANum:p,poolCoinBNum:$,poolCoinAUSD:Z,poolCoinBUSD:I,quoteUSD:it,poolUSD:et,balance:T})}this.positionInfoList=a},async updatePositionItem(e){var st,rt,et,it,at,lt,nt,pt;const m=dt("Sui"),d=qt("Sui"),a=await m.getAutoPool(e),n=await d.getPool(a.pool_id),u={...this.positionInfoObj[e],autoPoolPositionInfo:a.positins[0],...n},O=await m.getLpBalance(u.lp_token_type),N=(await d.getTokenListByCoinType([u.lp_token_type]))[0],s=u.autoPoolPositionInfo.tick_lower_index,L=u.autoPoolPositionInfo.tick_upper_index,i=G.get_share_liquidity_by_amount({liquidity:a==null?void 0:a.liquidity,total_supply:a==null?void 0:a.total_supply},O),k={tick_lower_index:s,tick_upper_index:L,current_sqrt_price:n.current_sqrt_price,liquidity:i},T=d.getCoinAmountFromLiquidity({pool:{current_sqrt_price:n.current_sqrt_price,...u},position:k,roundUp:!1}),M=T.coinaAmount,J=T.coinbAmount,{RATES:E}=this.getPoolStore,t=a.total_supply,c=yt.sqrtPriceX64ToPrice(n.current_sqrt_price,(st=u==null?void 0:u.coinA)==null?void 0:st.decimals,(rt=u==null?void 0:u.coinB)==null?void 0:rt.decimals),y=2,S=2,D=((it=E[(et=u==null?void 0:u.coinA)==null?void 0:et.address])==null?void 0:it.price)||0,x=((lt=E[(at=u==null?void 0:u.coinB)==null?void 0:at.address])==null?void 0:lt.price)||0,g=new o(D).mul(new o(T==null?void 0:T.coinaAmount)).toNumber(),q=new o(x).mul(new o(T==null?void 0:T.coinbAmount)).toNumber(),C=g>0&&g<.01?"<$0.01":`$${_t(h(g,2))}`,l=q>0&&q<.01?"<$0.01":`$${_t(h(q,2))}`;let A=new o(0);Number(O)>0&&(A=new o(O).div(Math.pow(10,N==null?void 0:N.decimals)));const f=new o(g).add(new o(q)).toNumber(),B=D&&x?f>0&&f<.01?"<0.01":h(new o(g).add(new o(q)).toString(),2):"--",r=new o(A).mul(Math.pow(10,(nt=u.lpInfo)==null?void 0:nt.decimals)).div(new o(t)).mul(100).toNumber(),b=new o(1).div(Math.pow(10,u.decimals)).toNumber();let P=0;if(r>1)P=h(r,2);else if(r>0&&r<b)P=`<${b}`;else if(r==0)P=0;else{const wt=bt(r),ft=wt==-1?2:wt+2;P=h(r,ft)}yt.sqrtPriceX64ToPrice(n.current_sqrt_price,y,S);const w=await d.getCoinAmountFromLiquidity({pool:{...u,tick_lower_index:s,tick_upper_index:L,current_sqrt_price:n==null?void 0:n.current_sqrt_price},position:{...k,liquidity:a.liquidity},roundUp:!1}),v=new o(w.coinaAmount).toNumber(),p=new o(w.coinbAmount).toNumber(),$=h(new o(v).mul(new o(D)).toNumber(),2),Z=h(new o(p).mul(new o(x)).toNumber(),2),{ratioA:I,ratioB:tt}=G.calculateDepositRatio(s,L,new V.BN(n==null?void 0:n.current_sqrt_price)),R=I.mul(100).toNumber().toFixed(0),U=100-Number(R),F=(await d.getTokenListByCoinType([a.quota_based_type]))[0],Q=ut(a.max_quota,F.decimals),X=F.address==u.coin_b_address,K=X?new o(w.coinaAmount).mul(u.price).add(w.coinbAmount):new o(w.coinaAmount).mul(1/u.price).add(w.coinbAmount),H=((pt=E[F.address])==null?void 0:pt.price)||"",j=K.mul(new o(H)).toNumber(),W=Q,Y=X?new o(w.coinaAmount).mul(u.price).add(w.coinbAmount):new o(w.coinaAmount).mul(1/u.price).add(w.coinbAmount),ot=new o(W).sub(Y).mul(x).toNumber(),At=d.TickMath.tickIndexToPrice(Number(s),y,S).toString(),ct=d.TickMath.tickIndexToPrice(Number(L),y,S).toString();this.positionInfoObj[e]={...u,tick_lower_index:s,tick_upper_index:L,current_sqrt_price:n.current_sqrt_price,myLiquidity:ut(O,N==null?void 0:N.decimals),amountA:M,amountB:J,myShare:P,myAmountAUSD:C,myAmountBUSD:l,myLiquidityUSD:B,poolCoinARatio:R,poolCoinBRatio:U,poolCoinANum:v,poolCoinBNum:p,poolCoinAUSD:$,poolCoinBUSD:Z,quoteUSD:W,balance:O,price:c,quoteCoinInfo:F,remainingTokenUSD:ot,currentDeposit:j,poolUSD:j,positionLiquidity:i,liquidity:a==null?void 0:a.liquidity,minPrice:At,maxPrice:ct},this.autoPoolLoading=!1},async getAutoPoolAPY(){try{const{data:e}=await fetch(`${_.Sui.api}/v2/sui/auto_pools`).then(m=>m.json());e&&e.pools&&e.pools.length>0&&(this.apyObj=Object.fromEntries(e.pools.map((m,d)=>[m.object_id,{...m,apr:m.apr.replace("%","")>0&&m.apr.replace("%","")<.01?"<0.01%":h(m.apr.replace("%",""),2)+"%",resultApr:m.apr.replace("%","")}])))}catch{this.apyObj={}}},async getVault(e){const m=dt("Sui");this.autoPoolLoading=!0;const{status:d}=await m.getVault(e);this.currentAutoPoolStatus=d,this.updatePositionItem(e)},setSlippage(e){this.slippage=e,localStorage.setItem("cetus-auto-slippage",e)}}});export{dt as a,Ot as u};
